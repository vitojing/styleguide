<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Google JavaScript 代码规范</title>
<link rel="stylesheet" href="javaguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico">
<script src="include/jsguide.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>JavaScript 代码规范</h1>
<h2 id="introduction">1 介绍</h2>

<p>本文档定义了Javascript语言的编码规范，一个Javascript源代码只有符合本文当所有规范才算符合编码规范。</p>

<p>与其他语言类似，代码规范不仅包含影响美感的代码格式，也包含其他规约和编码标准。然而，此文当侧重于一般情况下我们必须遵守的规则，而避免提出一些可能难以执行的建议。</p>

<p>所有示例中的写法并不是唯一符合规范的写法，不需要将示例当作规则去执行。</p>

<h2 id="source-file-basics">2 源文件基本要求</h2>

<h3 id="file-name">2.1 文件名</h3>

<p>文件名必须全小写，可以包含下划线 (<code>_</code>) 或者破折号 (<code>-</code>)，不能包含其他标点。</p>

<h3 id="file-encoding">2.2 文件编码：UTF-8</h3>

<p>源文件必须使用 <strong>UTF-8</strong> 编码。</p>

<h3 id="special-characters">2.3 特殊字符</h3>

<h4 id="whitespace-characters">2.3.1 空白字符</h4>

<p>除换行符外，只允许使用空格 (ASCII 0x20) 作为空白字符。这意味着：</p>

<ol>
<li><p>字符串中的所有其他空白字符必须意转义字符的形式出现。</p></li>
<li><p>禁止使用 tab 进行缩进。</p></li>
</ol>

<h4 id="special-escape-sequences">2.3.2 特殊转义序列</h4>

<p>对所有有专用文字转义表达方式的转义字符 (<code>\'</code>, <code>\"</code>, <code>\\</code>, <code>\b</code>,
<code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>)，只能使用字符转义方式，禁止使用数字转义 (即 <code>\x0a</code>, <code>\u000a</code>, or <code>\u{a}</code>)。禁止使用8进制数字转义。</p>

<h4 id="non-ascii-characters">2.3.3 非 ASCII 字符</h4>

<p>对非 ASCII 字符，要么使用原 Unicode 字符（例如 <code>&#8734;</code> ），要么使用对应的十六进制或者 Unicode 转义 (例如 <code>\u221e</code>)，以使代码易读易理解为选择标准。</p>
</p>

<p class="tip">提示：使用 Unicode 转义，或者直接使用 Unicode 字符时，一段注释说明往往很有帮助。</p>

<table>
  <thead>
    <tr>
      <th>示例
      </th><th>说明
  </th></tr></thead><tbody>
    <tr>
      <td><code class="prettyprint lang-js">const units = '&#956;s';</code>
      </td><td>很好，即使没有注释含义也很清晰。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // '&#956;s'
        </code>
      </td><td>允许这样写，但没有任何理由这样写。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // Greek letter mu, 's'
        </code>
      </td><td>允许这样写，但很别扭且容易出错。
    </td></tr><tr>
      <td><code class="badcode">const units = '\u03bcs';</code>
      </td><td>很糟糕，读者无法理解这段代码的含义。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">return '\ufeff' + content;  // byte order mark
        </code>
      </td><td>
        很好，针对无法显示的字符使用转义表示，并且添加了必要的注释。
</td></tr></tbody></table>

<p class="tip">提示：千万不要仅仅因为担心其他程序无法正确处理非 ASCII 字符而降低代码可读性。如果确实发生无法处理非 ASCII 字符的情况，那么这是该程序的问题，应该去修复程序。</p>

<h2 id="source-file-structure">3 源文件结构</h2>

<p>一个文件由以下几部分组成：</p>

<ol>
<li>文件概要信息</li>
<li>依赖声明</li>
<li>功能代码</li>
</ol>

<p>每部分之间留一个空行</p>


<h3 id="file-fileoverview">3.1 文件概要信息</h3>

<p>格式参照JSDoc相关用法。</p>

<h3 id="file-dependency">3.2 依赖声明</h3>

<p>所有对其他模块的依赖必须在此处统一声明，声明方式参照<a href="#module-pattern">??</a></p>

<p>每个引入的模块可以被赋值到一个不可变别名上，或者被解构为一组不可变别名。别名应该尽量与导入模块的完整限定名称的最后部分保持一致，当然也可以为了避免歧义、增强可读性也可以调整。</p>

<p>如果仅为了副作用而导入一个模块，可以不赋值，但需通过注释说明为何需要该模块，并且禁止编译器警告。</p>

<p>模块导入语句排序规则：所有带赋值的语句出现在前面，按照别名字符序排序，解构导入语句也如此。</p>

<p class="tip">提示：不需要记住并且手工执行这条规则，可以使用 IDE 进行 require 顺序检测。</p>

<p>模块引入代码行可不遵循单行80字符限制。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const MyClass = require('some/package/MyClass');
const NsMyClass = require('other/ns/MyClass');
const googAsserts = require('goog/asserts');
const testingAsserts = require('goog/testing/asserts');
const than80columns = require('pretend/this/is/longer/than80columns');
const {clear, forEach, map} = require('goog/array');
/** @suppress {extraRequire} Initializes MyFramework. */
require('my/framework/initialization');
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js badcode prettyprint">const randomName = require('something/else'); // name must match

const {clear, forEach, map} = // don't break lines
    require('goog/array');

function someFunction() {
  const alias = require('my/long/name/alias'); // must be at top level
  // &#8230;
}
</code></pre>

<h3 id="file-implementation">3.5 代码实现</h3>

<p>代码实现位于依赖声明语句之后，之间至少使用一个空行分隔。</p>

<p>这部分可能包含任何模块局部声明（例如常量，变量，类，函数等），以及任何导出符号。</p>

<h2 id="formatting">4 格式</h2>

<p><strong>术语说明</strong>: <em>块结构</em>是指类、函数、方法或者大括号包含的代码块。Note that, by
<a href="#features-array-literals">??</a> and <a href="#features-object-literals">??</a>, any array or
object literal may optionally be treated as if it were a block-like construct.</p>

<p class="tip">提醒：推荐使用 <code>clang-format</code>。Javascript社区投入很大努力使得 clang-format 可以应用于 Javascript 文件。<code>clang-format</code> 支持多种流行编辑器。</p>

<h3 id="formatting-braces">4.1 大括号</h3>

<h4 id="formatting-braces-all">4.1.1 对所有控制结构使用大括号</h4>

<p>对所有的控制结构使用大括号（例如 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>,
<code>while</code>，等等），即便其中只有一行代码。非空代码块的第一行必须以新行开始。</p>

<p>不规范写法：</p>

<pre><code class="language-js badcode prettyprint">if (someVeryLongCondition())
  doSomething();

for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);
</code></pre>

<p><strong>例外</strong>：如果一个简单的 if 语句能够放在一行内不需要换行，且没有 else 子句，那么为了增强可读性，允许将其放在一行并且不使用大括号。这是唯一一种可以在控制结构中捕食用大括号和换行的情况。</p>

<pre><code class="language-js prettyprint">if (shortCondition()) return;
</code></pre>

<h4 id="formatting-nonempty-blocks">4.1.2 非空代码块：K&amp;R 风格</h4>

<p>所有非空代码块和块结构都需要遵循 Kernighan and Ritchie 风格 (<q><a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a></q>)：</p>

<ul>
<li>左大括号前不换行。</li>
<li>左大括号后换行。</li>
<li>右大括号前换行。</li>
<li>如果右大括号标志着一个语句、函数体、类声明、类函数的结束，那么右大括号之后换行。也有例外情况，如果大括号后跟
  <code>else</code>, <code>catch</code>, <code>while</code>，或者逗号、分号、右小括号，那么大括号后不需要换行。</li>
</ul>

<p>示例：</p>

<pre><code class="language-js prettyprint">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code></pre>

<h4 id="formatting-empty-blocks">4.1.3 空代码块可以简化</h4>

<p>空代码块或块结构可以简写为 <code>{}</code>，如果其不是一个多代码块语句的一部分（例如 <code>if</code>/<code>else</code> 或者 <code>try</code>/<code>catch</code>/<code>finally</code>）。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function doNothing() {}
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">if (condition) {
  // &#8230;
} else if (otherCondition) {} else {
  // &#8230;
}

try {
  // &#8230;
} catch (e) {}
</code></pre>

<h3 id="formatting-block-indentation">4.2 使用两个空格缩进代码块</h3>

<p>每当产生一个新的代码块或块结构时，代码缩进增加两个空格。代码块结束时，缩进减少两个空格。缩进规则适用于代码和注释。示例参见 <a href="#formatting-nonempty-blocks">??</a>。</p>

<h4 id="formatting-array-literals">4.2.1 数组字面量：可以使用类块风格</h4>

<p>数组字面量可以采用块结构的格式进行格式化。例如以下形式都是合法的（未列出所有情况）：</p>

<pre><code class="language-js prettyprint columns">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code></pre>

<pre><code class="language-js prettyprint columns">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code></pre>

<p>也可以采用其他形式，例如出于强调元素的语义分类的目的，但不应该仅为了减少大数组所占的代码行。</p>

<h4 id="formatting-object-literals">4.2.2 对象字面量：可以使用类块风格</h4>

<p>对象字面量可以采用块结构的格式进行格式化。例如以下形式都是合法的（未列出所有情况）：</p>

<pre><code class="language-js prettyprint columns">const a = {
    a: 0,
    b: 1,
};

const b =
    {a: 0, b: 1};
</code></pre>

<pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code></pre>

<h4 id="formatting-class-literals">4.2.3 类字面量</h4>

<p>类字面量（无论是声明还是表达式）参照代码块进行缩进。不要在方法或者声明后添加分号(包含类声明的语句仍要以分号结尾，例如赋值语句)。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint columns">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
</code></pre>

<pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>

<h4 id="formatting-function-expressions">4.2.4 函数表达式</h4>

<p>函数调用语句的参数中包含匿名函数时，函数体缩进两个空格。</p>

<p>例子：</p>

<pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
  .thatsWrapped()
  .then((result) =&gt; {
    // Indent the function body +2 relative to the indentation depth
    // of the '.then()' call.
    if (result) {
      result.use();
    }
  });
</code></pre>

<h4 id="formatting-switch-statements">4.2.5 Switch 语句</h4>

<p>switch 代码块缩进两个空格。</p>

<p>每个 case 标签之后换行，对应标签的处理代码参照块结构进行缩进，如果需要块级作用域可以使用大括号包括处理代码。</p>

<p>break 语句和下一个 case 语句之间可以留一个空行（可选）。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}
</code></pre>

<h3 id="formatting-statements">4.3 语句</h3>

<h4 id="formatting-one-statement-perline">4.3.1 每行一条语句</h4>

<p>每条语句之后都应该换行。</p>

<h4 id="formatting-semicolons-are-required">4.3.2 必须使用分号</h4>

<p>每条语句应该以分号结尾，禁止依赖自动添加分号的功能。</p>

<h3 id="formatting-column-limit">4.4 单行不超过80字符</h3>

<p>一般情况下，单行 JavaScript 代码不得超过80字符，如果超出则断行，参考<a href="#formatting-line-wrapping">??</a>。</p>

<p><strong>例外情况：</strong></p>

<ol>
<li>不可能遵守字符限制的情况，例如一个很长的 URL 字符串。</li>
<li><code>CommonJS require</code>、<code>import</code> 等不适合换行的语句。/li>
</ol>

<h3 id="formatting-line-wrapping">4.5 断行</h3>

<p><strong>术语说明</strong>：<em>断行</em>是指将一个表达式拆分为多行。</p>

<p>没有完备的，确定的的方法告诉你在各种情况下如何断行。同一段代码往往有多种断行方式。</p>

<p>注意：尽管断行一般是为了不超出单行字符数的限制，但开发人员也可以出于其他原因自行决定断行。</p>

<p>提示：可以通过将部分内容提取为一个函数或据不变量的方法来避免断行。</p>

<h4 id="formatting-where-to-break">4.5.1 从何处断行</h4>

<p>原则上尽量依照高层语义进行断行。</strong>. </p>

<p>推荐方案：</p>

<pre><code class="language-js prettyprint">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0f;
</code></pre>

<p>不推荐：</p>

<pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0f;
</code></pre>

<p>上例中，语义从高到低依次是赋值、除法、函数调用、参数、数字常量。</p>

<p>操作符断行规则：</p>

<ol>
<li>在操作符之后断行
<ol>
<li>该规则不适用于 <q>点</q> (<code>.</code>)，点本身不是操作符。</li>
</ol></li>
<li>函数或者构造函数名名与其左括号（<code>(</code>）写在一起。</li>
<li>逗号（<code>,</code>）前不断行。</li>
</ol>

<blockquote>
<p>注意：断行的主要目的是使代码清晰易读，不要为了最小化代码行而修改代码。</p>
</blockquote>

<h4 id="formatting-indent">4.5.2 延续行缩进至少四个空格</h4>

<p>发生断行时，除第一行的其他行（所谓延续行）相对于第一行至少缩进四个空格。</p>

<p>有多个延续行时，每行的缩进可能不同。一般来说，较深语义层次的代码行缩进更多，缩进量都是4的整倍数。两行缩进相同当且仅当他们的语义层次相同。</p>

<p><a href="#formatting-horizontal-alignment">??</a> 描述了通过使用不同个数的空格来对齐上下行的特定词句的情况，这是不推荐的。</p>

<h3 id="formatting-whitespace">4.6 空白</h3>

<h4 id="formatting-vertical-whitespace">4.6.1 空行</h4>

<p>单个空行在以下情况下出现：</p>

<ol>
<li>在类或对象字面量的连续两个函数定义之间。
<ol>
<li>例外：对象字面量的两个连续属性定义之间的空行是可选的，这种空行常用于字段分组。</li>
</ol></li>
<li>空行可以用于在函数内部划分逻辑块，蛋不允许以空行开始或结尾。</li>
<li>类、对象字面量的第一个函数之前或者最后一个函数之后可以有一个空行（不推荐，也不反对）。</li>
<li>文档中列举的其他情况（例如<a href="#file-goog-require">??</a>）。</li>
</ol>

<p>多个连续空行也是允许的，但不要求，也不反对。</p>

<h4 id="formatting-horizontal-whitespace">4.6.2 行内空白</h4>

<p>行内空格的使用可以分为三种情况：行首、行尾、行内。行首空白（也就是缩进）其他章节已讲过，行尾空白是不允许的。</p>

<p>除了语言本身要求或其他规范要求，以及字面量、注释、JSDoc之外，空白字符<em>仅</em>在以下情况下使用：</p>

<ol>
<li>分隔保留字（例如 <code>if</code>, <code>for</code>, <code>catch</code>）和之后的左括号<code>(</code>。</li>
<li>分隔保留字（例如 <code>else</code>, <code>catch</code>）和之前的右大括号<code>}</code>。</li>
<li>用于所有左大括号<code>{</code>之前，除以下例外情况：
<ol>
<li>当一个对象字面量作为函数的第一个参数或者数组字面量的第一个元素时，例如 <code>foo({a: [{c: d}]})</code>。</li>
<li>在模板扩展代码中，因为模板语法不允许，例如 <code>abc${1 + 2}def</code>。</li>
</ol></li>
<li>在二元或者三元操作符前后。</li>
<li>在逗号（<code>,</code>）或分号（<code>;</code>）之后。注意这些符号前不允许有空格。</li>
<li>对象字面量的冒号（<code>:</code>）之后。</li>
<li>在双斜线（<code>//</code>，行内注释）前后，以及多行注释<code>*</code>符号之后。此处也可以使用多个空格。</li>
<li>在 JSDoc 起始注释字符之后，以及结束字符前后（例如简短的类型声明或者赋值： <code>this.foo = /** @type
{number} */ (bar);</code> or <code>function(/** string */ foo) {</code>）。</li>
</ol>

<h4 id="formatting-horizontal-alignment">4.6.3 不建议水平对齐</h4>

<p><strong>术语说明</strong>: <em>水平对齐</em>是指通过在代码中添加不同数量的空格，使得前后代码行中的特定词语纵向对齐。</p>

<p>允许这种做法，但并不推荐。</p>

<p>下面一个是不对齐的例子，一个对齐的示例。两者都允许，但不推荐后者。</p>

<pre><code class="language-js prettyprint">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};
</code></pre>

<p>注意：对齐有助于可读性，但不利于后续维护。考虑一个后续的修改只涉及其中一行，但为了代码对齐可能需要修改很多行代码格式。最坏情况下这可能导致无意义的忙碌，最好情况下也会破坏版本信息，降低代码 review 和代码冲突处理效率。</p>

<h4 id="formatting-function-arguments">4.6.4 函数参数</h4>

<p>推荐将函数参数与函数名写在同一行。如果超出单行字符限制断行时，必须考虑可读性。可以尽量在80字符处断行以节约空间，也可以每个参数一行增强可读性。应该缩进四个空格。也可以与括号对齐，但不推荐这种做法。下面是常用的参数断行方式：</p>

<pre><code class="language-js prettyprint">// 参数另起一行，缩进四个空格。适合参数本身可以放到一行，但加上函数名、function关键词就超常的情况。
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // &#8230;
}

// 如果参数列表再长的话，在80字符处断行。
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // &#8230;
}

// 四个空格，每个参数一行。
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // &#8230;
}
</code></pre>

<h3 id="formatting-grouping-parentheses">4.7 推荐使用括号进行分组</h3>

<p>使用括号在表达式中进行分组时有益的。除非开发人员和评审人员都认为没有括号不会导致任何误解，对代码可读性也没有帮助，否则建议使用括号。不可能所有开发人员都牢记所有运算符优先级。</p>

<p>不要用括号把<code>delete</code>，<code>typeof</code>，<code>void</code>，<code>return</code>，<code>throw</code>，<code>case</code>，<code>in</code>，<code>of</code>，或者 <code>yield</code> 之后的表达式整个包括起来，这完全没必要。</p>

<p>类型转换必须使用括号：<code>/** @type {!Foo} */ (foo)</code>。</p>

<h3 id="formatting-comments">4.8 注释</h3>

<h4 id="formatting-block-comment-style">4.8.1 注释</h4>

<p>注释与同级代码缩进保持一致，可以是 <code>/* &#8230; */</code> 或者 <code>//</code> 的形式。
  多行注释 <code>/* &#8230; */</code>，除第一行之外必须以 * 开头，且与第一行的 * 对齐。
  如果函数调用中函数名和参数值含义不明确，可以在参数值之后补充注释。</p>

<pre><code class="language-js prettyprint">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code></pre>

<p>注释不要包括在星号或者其他字符绘制的框中。</p>

<p>在实现注释中不要使用文档注释 JSDoc (<code>/** &#8230; */</code>).</p>

<h2 id="language-features">5 语言特性</h2>

<p>JavaScript 有许多有风险的，甚至危险的特性。本节描述了哪些特性可以使用，那些不推荐使用，以及相关的使用限制。</p>

<h3 id="features-local-variable-declarations">5.1 局部变量声明</h3>

<h4 id="features-use-const-and-let">5.1.1 使用 <code>const</code> 以及 <code>let</code></h4>

<p>使用 <code>const</code> 或者 <code>let</code> 声明所有的局部变量。默认使用 <code>const</code>，除非变量会被再次赋值。禁止使用 <code>var</code>。</p>

<h4 id="features-one-variable-per-declaration">5.1.2 每个声明仅含一个变量</h4>

<p>每个局部变量声明仅包含一个变量，不允许类似 <code class="badcode">let a = 1, b = 2;</code> 的用法。</p>

<h4 id="features-declared-when-needed">5.1.3 按需声明，尽快初始化</h4>

<p>无需将局部变量声明统一写在代码块块起始位置，而应该在初次使用时声明，以使其作用范围最小化。</p>

<h4 id="features-declare-types-as-needed">5.1.4 按需声明类型</h4>

<p>JSDoc 类型注释可以写在类型声明上一行，也可以在行内，写在变量名之前。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];

/** @type {!Array&lt;number&gt;} */
const data = [];
</code></pre>

<p>提示：: 许多情况下编译器可以推断模板类型，但无法推断其参数类型，例如初始化字面量或者初始化函数不包含任何模板参数类型信息时（例如空数组，对象，<code>Map</code>，<code>Set</code>）。
这种情况下变量类型注释会很有用。</p>

<h3 id="features-array-literals">5.2 数组字面量</h3>

<h4 id="features-arrays-trailing-comma">5.2.1 尾元素后使用逗号</h4>

<p>最后一个元素与结尾中括号之间换行时，尾元素之后始终添加一个逗号。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const values = [
  'first value',
  'second value',
];
</code></pre>

<h4 id="features-arrays-ctor">5.2.2 不要使用可变参数的 <code>Array</code> 构造函数</h4>

<p>当添加或删除参数时，该构造函数很容易带来问题。使用字面量的方式初始化。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code></pre>

<p>第三行代码会导致如下问题：如果<code>x1</code>是个整数，那么<code>a3</code>会是一个长度等于<code>x1</code>的数组，元素均为<code>undefined</code>。
如果<code>x1</code>是其他数字，那么会产生异常。其他情况下会生成一个单元素的数组。</p>

<p>应该使用这种写法：</p>

<pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code></pre>

<p>如果需要，也可以使用 <code>new Array(length)</code> 显示分配一个特定长度的数组。</p>

<h4 id="features-arrays-non-numeric-properties">5.2.3 非数字属性</h4>

<p>不要在数组上定义或者使用非数字属性（除了<code>length</code>），使用<code>Map</code>或者<code>Object</code>。</p>

<h4 id="features-arrays-destructuring">5.2.4 解构</h4>

<p>解构赋值语法常用作赋值语句的左值（例如从一个数组中提取多个值）。结尾处可以包含一个<q>rest</q>元素（<code>...</code>和rest变量名之间不要有空格）。不需要的元素应该被忽略。</p>

<pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code></pre>

<p>解构语法也可以用于函数参数。如果数据参数是可选择，那么使用提供<code>[]</code>作为默认值，并且在左侧提供相应参数默认值：</p>

<pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };
</code></pre>

<p>提示：将函数参数或者返回值包装为一个变量时，推荐使用对象而不是数组，因为可以为变量元素指定名称并且每个元素类型可以不同。</p>

<h4 id="features-arrays-spread-operator">5.2.5 扩展操作符</h4>

<p>数组字面量内可以使用扩展操作符<code>...</code>从一个或者多个其他值中提取元素，使用扩展操作符而不要使用<code>Array.prototype</code>上的方法进行元素提取操作。<code>...</code>之后不要有空格。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">[...foo]   // 优于 Array.prototype.slice.call(foo)
[...foo, ...bar]   // 优于 foo.concat(bar)
</code></pre>

<h3 id="features-object-literals">5.3 对象字面量</h3>

<h4 id="features-objects-use-trailing-comma">5.3.1 尾元素后使用逗号</h4>

<p>最后一个元素与结尾大括号之间换行时，尾元素之后始终添加一个逗号。</p>

<h4 id="features-objects-ctor">5.3.2 不要使用<code>Object</code>构造函数</h4>

<p>尽管<code>Object</code>构造函数没有<code>Array</code>的问题，但出于一致性考虑，仍然不推荐该用法，使用对象字面量进行初始化，例如<code>{}</code> 或者 <code>{a: 0, b: 1, c: 2}</code>。</p>

<h4 id="features-objects-mixing-keys">5.3.3 不要混用加引号和不加引号的键</h4>

<p>对象字面量可以使用不加引号的键或者符号表示结构体，也可以使用加引号或者计算出的键表示字典。不要再单个对象字面量中混用这些键类型。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">{
  a: 42, // 结构体类型的不加引号的键
  'b': 43, // 字典类型的加引号的键
}
</code></pre>

<h4 id="features-objects-computed-property-names">5.3.4 计算属性名</h4>

<p>允许使用计算属性名（例如<code>{['key' + foo()]: 42}</code>）。计算属性名术语字典类型的键（意味着其不能与不加引号的键混用），除非该计算属性是一个 symbol（例如<code>[Symbol.iterator]</code>）。
 枚举值也可以用作计算属性，但不应该同其他非枚举键混用。</p>

<h4 id="features-objects-method-shorthand">5.3.5 方法简写</h4>

<p>对象字面量中的方法定义可以简写，例如：</p>

<pre><code class="language-js prettyprint">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
</code></pre>

<p>注意方法简写或者函数中的<code>this</code>指向对象字面量自身，而箭头函数中的<code>this</code>则与对象字面量外部作用域的<code>this</code>保持一致。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () =&gt; this.stuff,  // Returns 'fruit'
    };
  }
}
</code></pre>

<h4 id="features-objects-shorthand-properties">5.3.6 属性简写</h4>

<p>可以在对象字面量中使用属性简写，例如：</p>

<pre><code class="language-js prettyprint">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code></pre>

<h4 id="features-objects-destructuring">5.3.7 对象结构</h4>

<p>对象解构语法常用作赋值语句的左值，用于从单个对象中提取多个值。</p>

<p>解构对象也用于函数参数，但用法应该尽量简单，只使用单层不加引号的属性简写。不建议在参数解构中使用多层或者计算属性。
在参数解构语句的左值为参数指定默认值，例如<code>{str = 'some default'} = {}</code>而不是<code class="badcode">{str} = {str: 'some default'}</code>。
如果解构对象本身时可选的，那么必须指定默认值<code>{}</code>。JSDoc中可以为解构参数指定任何名字（该名字并不实际使用，但编译器要求提供）。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {})
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code></pre>

<p>解构语法也可以用于<code>goog.require</code>语句，此时不允许断行（见<a href="#file-goog-require">??</a>）。</p>

<h4 id="features-objects-enums">5.3.8 枚举</h4>

<p>通过在对象字面量上添加<code>@enum</code>注解来定义枚举。枚举定义后，不允许再添加属性。枚举必须是常量，所有枚举值必须是必须是不递归可变的。</p>

<pre><code class="language-js prettyprint">/**
 * 所支持的温标
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * 两个选项的枚举。
 * @enum {number}
 */
const Option = {
  /** 该选项必须是第一个 */
  FIRST_OPTION: 1,
  /** 第二个选项 */
  SECOND_OPTION: 2,
};
</code></pre>

<h3 id="features-classes">5.4 类</h3>

<h4 id="features-classes-constructors">5.4.1 构造函数</h4>

<p>具体类（concrete class）的构造函数是可选的。子类构造函数在访问<code>this</code>或者设置字段（fields）之前，必须先调用<code>super()</code>。接口不允许定义构造函数。</p>

<h4 id="features-classes-fields">5.4.2 字段（Fields）</h4>

<p>必须在构造函数中设置所有对象字段（即除了方法之外的所有属性）的值。
  给所有不变的字段添加<code>@const</code>注解（字段内容必须是深层不可变的 deeply immutable）。
  私有字段必须天津爱<code>@private</code>注解，名称必须以下划线结尾。
  不允许设置具体类（concrete class）原型的字段。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();
  }
}
</code></pre>

<p>提示：构造函数执行结束后，不允许在对象实例上添加或者删除属性，这会严重影响虚拟机的优化能力。
  如果确实有属性要延后初始化，在构造函数中将其设置为<code>undefined</code>。</p>

<h4 id="features-classes-computed-properties">5.4.3 计算属性</h4>

<p>只允许对 symbol 属性使用子酸属性。不幸允许使用字典类型的属性（见 <a href="#features-objects-mixing-keys">??</a>）。
  对可枚举的类需要定义<code>[Symbol.iterator]</code>方法。除此之外，<code>Symbol</code> 应该慎用。</p>

<p>提示：慎用其他内置 symbol（<code>Symbol.isConcatSpreadable</code>等），旧浏览器可能不支持。</p>

<h4 id="features-classes-static-methods">5.4.4 静态方法</h4>

<p>在不影响可读性的情况下，建议使用模块内局部函数而不会死私有静态方法。</p>

<p>静态函数只能在其定义所属的类上调用。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // 不推荐：不要以动态方式调用静态函数
Sub.foo();  // 非法使用：Sub自身没有定义foo静态方法，禁止这种用法
</code></pre>

<h4 id="features-classes-old-style">5.4.5 老式类定义</h4>

<p>尽管更推荐使用 ES6 的类定义方式，但一些情况下无法使用 ES6 的方式，例如：</p>

<ol>
<li><p>框架代码中的类被继承产生了子类，而这些子类无法立即使用 ES6 语法重写。如果父类切换到 ES6 语法，所有子类也必须修改。</p></li>
<li><p>在调用父类构造函数之前就需要使用 <code>this</code> 的情况。原因是 ES6 的父类构造函数调用<code>super</code>执行结束之前，不能访问<code>this</code>变量。</p></li>
</ol>

<p>同样，合适的情况下推荐使用<code>let</code>，<code>const</code>，默认参数，剩余参数，箭头函数。</p>

<p>类实例的属性应该在构造函数中进行设置，方法应该在构造函数原型上定义。</p>

<h4 id="features-classes-prototypes">5.4.6 尽量不要直接操作<code>prototype</code>s</h4>

<p>使用<code>class</code>关键词定义类比<code>prototype</code>的方式更简洁，可读性更强。一般代码不需要使用<code>prototype</code>。
  禁止在内置对象上使用混入（Mixin）或者修改内置对象原型。</p>

<p><strong>例外</strong>：框架代码（例如Polymer, Angular）可能仍要使用<code>prototype</code>s，以避免更糟糕的解决方案。</p>

<p><strong>例外</strong>：在接口上定义字段（见 <a href="#features-classes-interfaces">??</a>）。</p>

<h4 id="features-classes-getters-and-setters">5.4.7 Getters & Setters</h4>

<p>不要使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">JavaScript getter 和 setter 属性</a>。
  getter 和 setter 有一些奇怪而难以理解的特性，并且编译器对其支持有限。推荐使用普通方法。</p>

<p><strong>例外</strong>：在数据绑定框架（例如Angular，Polymer）中可以少量使用getter和setter，
  并且要用 <code>get foo()</code> 、 <code>set foo(value)</code>，或者 <code>Object.defineProperties</code> 的形式，
  不要使用 <code>Object.defineProperty</code>，因为其函数名容易与属性重命名混淆。Getters 中不允许修改可观测状态。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">class Foo {
  get next() { return this.nextId++; }
}
</code></pre>

<h4 id="features-classes-overriding-tostring">5.4.8 重载 toString</h4>

<p>可以按需重载 <code>toString</code> 方法，但该方法必须始终成功，且不能有可见的副作用。</p>

<p>提示：尤其要注意在 toString 中调用其他函数的情况，因为特定情况下可能导致死循环。</p>

<h4 id="features-classes-interfaces">5.4.9 接口</h4>

<p>使用<code>@interface</code> 或者 <code>@record</code>注解来声明接口。</p>

<p>接口上的非静态方法必须是空方法。接口字段必须在<code>prototype</code>上定义。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

/** @type {number} The number of attempts before giving up. */
Frobnicator.prototype.attempts;
</code></pre>

<h3 id="features-functions">5.5 函数</h3>

<h4 id="features-functions-top-level-functions">5.5.1 顶级函数</h4>

<p>导出函数可以直接在<code>export</code>对象上定义，也可以声明然后另外导出。鼓励使用非导出函数，不需要使用<code>@private</code>注解。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/** @return {number} */
function helperFunction() {
  return 42;
}
/** @return {number} */
function exportedFunction() {
  return helperFunction() * 2;
}
/**
 * @param {string} arg
 * @return {number}
 */
function anotherExportedFunction(arg) {
  return helperFunction() / arg.length;
}
/** @const */
exports = {exportedFunction, anotherExportedFunction};
</code></pre>

<pre><code class="language-js prettyprint">/** @param {string} arg */
exports.foo = (arg) =&gt; {
  // do some stuff ...
};
</code></pre>

<h4 id="features-functions-nested-functions">5.5.2 嵌套函数与闭包</h4>

<p>函数中可以包含嵌套函数定义。只能将函数赋给一个常量。</p>

<h4 id="features-functions-arrow-functions">5.5.3 箭头函数</h4>

<p>箭头函数语法简介，并且解决了<code>this</code>的一些难题。优先使用箭头函数而不是<code>function</code>关键词，尤其是定义嵌套函数时（例外情况见 <a href="#features-objects-method-shorthand">??</a>）。</p>

<p>推荐使用箭头函数而不是 <code>f.bind(this)</code>。避免<code>const self = this</code>的写法。回调函数有时会传递一些意料之外的参数，箭头函数在这种情况下尤其有用。</p>

<p>箭头函数右侧部分可以是表达式或是代码块。如果箭头函数只有一个非结构参数，参数外围的圆括号是可选的。</p>

<p>提示：始终使用圆括号包括参数是个好习惯，因为如果没有括号，可能后续添加了一个参数但漏了括号，此时代码不会报错，但结果是错的。</p>

<h4 id="features-functions-generators">5.5.4 生成器函数（Generators）</h4>

<p>生成器函数提供了一些高级抽象特征，可以按需使用。</p>

<p>定义生成器函数时，<code>*</code>符号紧贴在<code>function</code>关键词后，与函数名之前用一个空格分隔。
  使用代理yield（delegating yield）时，<code>*</code>符号紧贴在<code>yield</code>关键词后。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
</code></pre>

<h4 id="features-functions-parameters">5.5.5 参数</h4>

<p>在书定义前必须使用JSDoc注解声明所有函数参数类型。使用<code>@override</code>注解重写相同签名的父类函数时，可以忽略参数类型声明。</p>

<p>也可以在行内声明参数类型（例如<code>(/** number */ foo, /** string */ bar) =&gt; foo + bar</code>）。同一个函数上行内声明和<code>@param</code>形式的类型注解不能混合使用。</p>

<h5 id="features-functions-default-parameters">5.5.5.1 默认参数</h5>

<p>可选参数出现在必填参数之后，命名与其他参数相同（不要使用<code>opt_</code>前缀等），必须指定默认值（即使默认值是<code>undefined</code>），等号前后各一个空格。
  在JSDoc中使用<code>=</code>进行类型声明。默认值初始化不能产生副作用。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} required - 必填参数
 * @param {string=} optional - 该参数可忽略
 * @param {!Node=} node - 另一个可忽略的参数
 */
function maybeDoSomething(required, optional = '', node = undefined) {}
</code></pre>

<p>如果有多个可选参数，且之间没有明确的顺序，优先使用解构语法（<a href="#features-objects-destructuring">??</a>）</p>

<p>注意：与Python不同的是，javascript参数默认值中初始化对象（例如<code>{}</code> 或者 <code>[]</code>）是安全的，
  因为每次应用参数默认值时默认值初始化方法都会执行，因此不同的调用之间不会共用一个对象。</p>

<p>提示：尽管包括函数调用之内的任意表达式都可以用于默认值初始化，但初始化方式应该尽量简单。应该尽量避免初始化默认值中使用共享的可变状态，这可能会导致不同的函数调用之间产生耦合。</p>

<h5 id="features-functions-rest-parameters">5.5.5.2 剩余参数</h5>

<p>不要使用<code>arguments</code>，使用剩余参数。JSDoc中使用<code>...</code>声明剩余参数的类型。
  剩余参数必须是参数列表中的最后一个参数。<code>...</code>和参数名之间不能有空格。不要将其命名为<code>var_args</code>。
  不要将局部变量或者参数命名为<code>arguments</code>，以免与内置变量混淆。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {!Array&lt;string&gt;} array - 普通参数
 * @param {...number} numbers 剩余的参数都是数字
 */
function variadic(array, ...numbers) {}
</code></pre>

<h4 id="features-functions-returns">5.5.6 返回值</h4>

<p>在函数JSDoc注释中声明返回值类型，使用<code>@override</code>注解重写相同签名的父类函数时，可以忽略类型声明。</p>

<h4 id="features-functions-spread-operator">5.5.7 扩展操作符（Spread operator）</h4>

<p>可以在调用函数时使用扩展操作符<code>...</code>。
  需要将数组或可枚举对象解析为可变长参数函数（variadic function）的多个参数时，推荐使用扩展操作符而不是<code>Function.prototype.apply</code>。
  <code>...</code>之后不要添加空格。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code></pre>

<h3 id="features-string-literals">5.6 字符串字面量</h3>

<h4 id="features-strings-use-single-quotes">5.6.1 使用单引号</h4>

<p>使用单引号（<code>'</code>）包括普通字符串字面量，不要使用双引号（<code>"</code>）。</p>

<p>提示：如果字符串中包含单引号，考虑使用模板字符串，以避免使用转义。</p>

<p>普通字符串字面量不能跨行。</p>

<h4 id="features-strings-template-strings">5.6.2 模板字符串</h4>

<p>使用模板字符串不要使用复杂的子字符串拼接，尤其是涉及多个字符串字面量时。模板字符串可以跨行。</p>

<p>模板字符串跨多行时，不需要遵循其所在块的缩进。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code></pre>

<h4 id="features-strings-no-line-continuations">5.6.3 不要使用续行符（line continuations）</h4>

<p>无论在普通字符串还是模板字符串中都不要使用续行符。如果反斜线之后有空白会很难观察，这可能会导致难以发觉的错误。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';
</code></pre>

<p>推荐写法：</p>

<pre><code class="language-js prettyprint">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
</code></pre>

<h3 id="features-number-literals">5.7 数字字面量</h3>

<p>可以使用十进制，十六进制，八进制，或者二进制形式的数字。对十六进制、八进制、二进制数字时分别添加小写 <code>0x</code>,
<code>0o</code>, and <code>0b</code> 前缀。非前缀部分不要以0开头。</p>

<h3 id="features-control-structures">5.8 控制解构</h3>

<h4 id="features-for-loops">5.8.1 For 循环</h4>

<p>ES6语法包含三种形式的<code>for</code>循环。三种均可使用，其中更推荐<code>for</code>-<code>of</code>形式。</p>

<p><code>for</code>-<code>in</code> 循环只能用于字典风格的对象（见<a href="#features-objects-mixing-keys">??</a>），
  不能用于遍历数组。可以在<code>for</code>-<code>in</code>循环中使用<code>Object.prototype.hasOwnProperty</code>以过滤掉原型上的属性。
  推荐使用<code>for</code>-<code>of</code>和<code>Object.keys</code>而不要使用<code>for</code>-<code>in</code>。</p>

<h4 id="features-exceptions">5.8.2 异常</h4>

<p>异常是javascript语言的重要组成部分。在发生意外情况时，始终抛出<code>Error</code对象或者其子类对象，不要直接抛出字符串或者其他对象。
  使用<code>new</code>>操作符构在<code>Error</code>对象。</p>

<p>自定义异常对象可以提供额外的错误信息，当内置<code>Error</code>类型不能满足需求时建议使用自定义对象。</p>

<p>需要时推荐抛出异常而不是使用自定义的错误处理机制（例如返回数据中包含一个是否发生错误的属性）。</p>

<h5 id="features-empty-catch-blocks">5.8.2.1 空 catch 块</h5>

<p>大部分情况下在异常处理代码块中不做任何处理是有问题的。如果确实要这么做，在注释中写一下原因。</p>

<pre><code class="language-js prettyprint">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">   try {
    shouldFail();
    fail('expected an error');
  }
  catch (expected) {}
</code></pre>

<p>提示：上面代码在javascript中的行为与其他语言不太相同，因为javascript没有指定参数类型的机制，
  不会判断异常实例是否是catch子句中指定的类型，因此<code>fail</code>抛出的异常始终会被捕获。
  如果有根据类型进行处理的需求可以使用<code>assert.throws</code>。</p>

<h4 id="features-switch-statements">5.8.3 Switch 语句</h4>

<p>术语说明：switch代码块内部包含一个或多个语句组，每个语句组包含一个或多个switch标签（<code>case FOO:</code> 或 <code>default:</code>），后跟一个或多个语句。</p>

<h5 id="features-switch-fall-through">5.8.3.1 fall-through</h5>

<p>switch语句中的每个语句组要么显示结束（以<code>break</code>，<code>return</code>，或者<code>throw</code>的形式），
  要么添加注释说明会继续执行下一个语句组中的代码（例如<code>// fall through</code>）。最后一个语句组不需要添加该注释。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code></pre>

<h5 id="features-switch-default-case">5.8.3.2 始终添加 <code>default</code> 语句组</h5>

<p>每个switch表达式都要包含一个<code>default</code>语句组，即使其中没有任何处理逻辑。</p>

<h3 id="features-this">5.9 this</h3>

<p>只在类构造函数或方法，或者其内部的箭头函数中使用<code>this</code>。其他情况下使用<code>this</code>时必须在其最近的函数JSDoc中对<code>this</code>进行声明。</p>

<p>不要使用<code>this</code>引用全局对象，<code>eval</code>的上下文，事件（event）关联的对象（target），或者使用<code>call()</code>或者<code>apply()</code>调用的函数。</p>

<h3 id="module-pattern">5.10 模块化机制</h3>

<p>在route层代码中使用ES6或者CommonJS模块化机制均可，但用法要统一，不要混用。推荐使用ES6模块化机制。</p>

<p>目前平台上的浏览器代码统一使用webpack提供的模块化能力，webpack支持CommonJS、AMD、ES6标准以及webpack自定义的模块化机制。</p>

<p>推荐使用ES6模块化机制，CommonJS、AMD也可使用，如非必要不要使用webpack自定义的机制。</p>

<p>如果需要代码分割，使用AMD的require机制。</p>

<p>注意：应用对其他应用提供的widget随应用本身发布，其他应用在html中通过script标签引用改widget。为保证执行顺序可靠性，所有widget不允许使用AMD的require机制。</p>

<h3 id="disallowed-features">5.11 禁止使用的特性</h3>

<h4 id="disallowed-features-with">5.11.1 with</h4>

<p>不要使用<code>with</code>关键词，该特性不利于代码可读性，在ES5严格模式中已经被禁止使用。</p>

<h4 id="disallowed-features-dynamic-code-evaluation">5.11.2 动态执行代码</h4>

<p>不要使用<code>eval</code>或者<code>Function(...string)</code>构造函数（除了用于代码加载工具中），这些特性存在潜在的危险性。</p>

<h4 id="disallowed-features-automatic-semicolon-insertion">5.11.3 自动插入分号</h4>

<p>除了函数和类声明之外，所有语句一律以分号结尾。</p>

<h4 id="disallowed-features-non-standard-features">5.11.4 非标准特性</h4>

<p>不要使用非标准特性，包括已删除的功能（例如<code>WeakMap.clear</code>），尚未标准化的新特性（当前的TC39草案，各阶段提案，或者提出但尚未完成的web标准），
  或者部分浏览器的专利特性。只使用当前ECMA-262或者WHATWG标准中包含的特性。当然专为Node.js或者Chrome扩展所写的代码不受该限制约束。禁止使用非标准语言扩展。</p>

<h4 id="disallowed-features-wrapper-objects">5.11.5 原生类型对象封装</h4>

<p>不要在原生类型对象封装（例如<code>Boolean</code>, <code>Number</code>, <code>String</code>,
  <code>Symbol</code>）上使用<code>new</code>操作符，也不要再类型注解中使用原生类型对象封装。</p>

<p>不规范用法：</p>

<pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
</code></pre>

<p>原生类型对象封装一般用于强制类型转换或者创建symbols。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected
</code></pre>

<h4 id="disallowed-features-modifying-builtin-objects">5.11.6 修改内建对象</h4>

<p>不要修改内建类型，也不要依赖有这种行为的库。</p>

<h2 id="naming">6 命名</h2>

<h3 id="naming-rules-common-to-all-identifiers">6.1 标志符（Identifier）通用规则</h3>

<p>标志符中只能使用ASCII字符和数字，在下面所列的少数情况下可以使用下划线和美元符号。</p>

<p>标志符命名尽量是自描述的。不要考虑缩短命名以节省空间，让其他人能够迅速理解代码要重要的多。
  不要使用项目外其他人不理解或者不熟悉的缩写，不要以删除单词中间字符的方式进行缩写。</p>

<pre><code class="language-js prettyprint">priceCountReader      // 不要使用缩写
numErrors             // "num" 是广泛使用的惯例用法
numDnsConnections     // 大部分人都明白Dns的含义
</code></pre>

<p>不规范用法：</p>

<pre><code class="language-js prettyprint badcode">n                     // 缺乏语义
nErr                  // 语义模糊的缩写
nCompConns            // 语义模糊的缩写
wgcConnections        // 只有自己项目组成员明白其含义
pcReader              // pc可以代表许多含义
cstmrId               // 删除中间字符
kSecondsPerDay        // 不要使用匈牙利命名法
</code></pre>

<h3 id="naming-rules-by-identifier-type">6.2 标志符类型相关规则</h3>

<h4 id="naming-package-names">6.2.1 Package命名</h4>

<p>Package统一使用小驼峰法命名，例如使用<code>my.exampleCode.deepSpace</code>，
  不要使用<code class="badcode">my.examplecode.deepspace</code>或者<code class="badcode">my.example_code.deep_space</code>。</p>

<h4 id="naming-class-names">6.2.2 类命名</h4>

<p>类、接口使用大驼峰命名法。局部的但不是私有的类称为非导出类（unexported classes），这些类不会添加<code>@private</code>注解，因此其名字也不需要以下划线结尾。</p>

<p>类型名一般是名词或者名词短语，例如<code>Request</code>、<code>ImmutableList</code>、<code>VisibilityMode</code>。
  此外，接口名可以是形容词或者形容词类型的短语，例如<code>Readable</code>。</p>

<h4 id="naming-method-names">6.2.3 函数名</h4>

<p>函数使用小驼峰法命名，私有函数名称以下划线结尾。</p>

<p>方法名一般是动词或动词短语，例如<code>sendMessage</code>或者<code>stop_</code>。
  函数的getter和setter方法不是必要的，如果有的话应该使用<code>getFoo</code>和<code>setFoo(value)</code>的形式。</p>

<p>下划线也可以在测试用例名称中用于分隔名称的不同部分，一种典型用法是<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，
  例如<code>testPop_emptyStack</code>>。测试用例命名没有统一的方法。</p>

<h4 id="naming-enum-names">6.2.4 枚举命名</h4>

<p>枚举使用大驼峰命名法。，一般使用单个名词。枚举元素参照常量命名。</p>

<h4 id="naming-constant-names">6.2.5 常量命名</h4>

<p>常量采用大写常量命名方式（CONSTANT_CASE）：所有字符大写，使用下划线连接多个单词。不需要使用尾下划线，因为静态私有属性可以使用模块局部常量代替。</p>

<h5 id="naming-definition-of-constant">6.2.5.1 常量定义 of &#8220;constant&#8221;</h5>

<p>常量是添加<code>@const</code>注解的静态属性或者模块局部的<code>const</code>声明，但不是所有这些用法都是常量。
  能否作为常量的原则是其是否是深度不变的（deeply immutable）。例如如果一个实例的任何一个可观测状态可能发生变化，那么它就不是常量。
  仅仅不修改对象实例是不够的。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">// 常量
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// 非常量
let letVariable = 'non-const';
class MyClass { constructor() { /** @const */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';
const /** Set&lt;String&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // mirrors imported name
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>

<p>常量名一般是名词或者名词短语></p>

<h5 id="naming-local-aliases">6.2.5.1 本地别名</h5>

<p>常使用本地别名代替完整以增强可读性。本地别名命名参照<code>goog.require</code>s
（<a href="#file-goog-require">??</a>），一般使用原名称最后一部分作为别名。别名必须使用<code>const</code>声明。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code></pre>

<h4 id="naming-non-constant-field-names">6.2.6 非常量字段名</h4>

<p>非常量字段名（无论是否静态）使用小驼峰命名法，私有字段以下划线结尾。</p>

<p>字段名一般是名词或者名词短语，例如<code>computedValues</code>或者<code>index_</code>。</p>

<h4 id="naming-parameter-names">6.2.7 参数名</h4>

<p>参数名使用小驼峰命名法。</p>

<p>公开方法参数不能使用单字符参数名。</p>

<p><strong>例外</strong>：如果第三方框架需要，参数名可以以<code>$</code>开头。</p>

<h4 id="naming-local-variable-names">6.2.8 局部变量命名</h4>

<p>局部变量使用小驼峰命名法，前面提到的模块顶层局部常量除外。函数内部的常量仍然使用小驼峰命名法。即使变量包含的是构造函数，也仍然使用小驼峰法命名。</p>

<h4 id="naming-template-parameter-names">6.2.9 模板参数命名</h4>

<p>模板参数命名应该简洁，一般是单个单词或者单字符，且全大写，例如<code>TYPE</code>或者<code>THIS</code>。</p>

<h3 id="naming-camel-case-defined">6.3 驼峰法定义</h3>

<p>对于首字母缩略词等情况（例如<q>IPv6</q>或者<q>iOS</q>）来说，没有确定的方式将其转换为驼峰式写法。为增强可预测性，本代码规范制定了下列转换方法。以</p>

<p>转换规则以名称的普通可读文本形式作为输入：</p>

<ol>
<li>将其转换为普通ASCII，移除单引号。例如，<q>M&#252;ller's algorithm</q>会被转换<q>Muellers algorithm</q>。</li>
<li>根据空格、连字符或其他标点符号将结果分隔为多个词。
<ol>
<li>建议：如果一个词已经有常见的驼峰写法，将其分割为多个连续的部分（例如将<q>AdWords</q>分割为<q>ad words</q>）。
  注意有些词本身并不属于驼峰写法，例如<q>iOS</q>，这种写法不符合任何管理，因此不适用该建议。</li>
</ol></li>
<li>全部转换为小写，然后对于大驼峰法将所有单词的首字符大写，对于小驼峰法将除第一个之外单词首字符大写。
<li>最后将所有单词拼接为一个标志符。</li>
</ol>

<p>注意以上过程几乎完全不考虑名称的原始大小写。</p>

<p>示例：</p>

<table>
<thead>
<tr>
<th style="text-align: center">Prose form</th>
<th style="text-align: center">Correct</th>
<th style="text-align: center">Incorrect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center"><q>XML HTTP request</q></td>
<td style="text-align: center">XmlHttpRequest</td>
<td style="text-align: center">XMLHTTPRequest</td>
</tr>
<tr>
<td style="text-align: center"><q>new customer ID</q></td>
<td style="text-align: center">newCustomerId</td>
<td style="text-align: center">newCustomerID</td>
</tr>
<tr>
<td style="text-align: center"><q>inner stopwatch</q></td>
<td style="text-align: center">innerStopwatch</td>
<td style="text-align: center">innerStopWatch</td>
</tr>
<tr>
<td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
<td style="text-align: center">supportsIpv6OnIos</td>
<td style="text-align: center">supportsIPv6OnIOS</td>
</tr>
<tr>
<td style="text-align: center"><q>YouTube importer</q></td>
<td style="text-align: center">YouTubeImporter</td>
<td style="text-align: center">YoutubeImporter*</td>
</tr>
</tbody>
</table>

<p>*可接受，单不推荐。</p>

<p>注意：英语中有些词可使用也可不用连字符，例如<q>nonempty</q>和<q>non-empty</q>都是正确的，因此函数名checkNonempty和checkNonEmpty也都是合法的。</p>

<h2 id="jsdoc">7 JSDoc</h2>

<p>参照JSDoc规范。</p>

</div>
</body>
</html>
