<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Google JavaScript 代码规范</title>
<link rel="stylesheet" href="javaguide.css">
<script src="include/styleguide.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico">
<script src="include/jsguide.js"></script>
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Google JavaScript 代码规范</h1>
<h2 id="introduction">1 介绍</h2>

<p>本文档定义了Google Javascript语言的编码规范，一个Javascript源代码只有符合本文当所有规范才算符合Google 编码规范。</p>
<p>This document serves as the complete definition of Google’s coding standards for source code in the JavaScript programming language. A JavaScript source file is described as being in Google Style if and only if it adheres to the rules herein.</p>

<p>与其他语言类似，代码规范不仅包含影响美感的代码格式，也包含其他规约和编码标准。然而，此文当侧重于一般情况下我们必须遵守的规则，而避免提出一些可能难以执行的建议。</p>
<p>Like other programming style guides, the issues covered span not only aesthetic
issues of formatting, but other types of conventions or coding standards as
well. However, this document focuses primarily on the hard-and-fast rules that
we follow universally, and avoids giving advice that isn't clearly enforceable
(whether by human or tool). </p>

<h3 id="terminology-notes">1.1 术语说明</h3>

<p>In this document, unless otherwise clarified:</p>

<ol>
<li><p>The term <em>comment</em> always refers to <em>implementation</em> comments. We do not use
the phrase <q>documentation comments</q>, instead using the common term &#8220;JSDoc&#8221;
for both human-readable text and machine-readable annotations within
<code>/** &#8230; */</code>.</p></li>
<li><p>This Style Guide uses <a href="http://tools.ietf.org/html/rfc2119">RFC 2119</a> terminology when using the phrases <em>must</em>,
<em>must not</em>, <em>should</em>, <em>should not</em>, and <em>may</em>.  The terms <em>prefer</em> and
<em>avoid</em> correspond to <em>should</em> and <em>should not</em>, respectively.  Imperative
and declarative statements are prescriptive and correspond to <em>must</em>.</p></li>
</ol>

<p>Other <q>terminology notes</q> will appear occasionally throughout the document.</p>

<h3 id="guide-notes">1.2 Guide notes</h3>

<p>Example code in this document is <strong>non-normative</strong>. That is, while the examples
are in Google Style, they may not illustrate the <em>only</em> stylish way to represent
the code. Optional formatting choices made in examples must not be enforced as
rules.</p>

<h2 id="source-file-basics">2 源文件基本要求</h2>

<h3 id="file-name">2.1 文件名</h3>

<p>文件名必须全小写，可以包含下划线 (<code>_</code>) 或者破折号 (<code>-</code>)，不能包含其他标点。</p>

<h3 id="file-encoding">2.2 文件编码：UTF-8</h3>

<p>源文件必须使用 <strong>UTF-8</strong> 编码。</p>

<h3 id="special-characters">2.3 特殊字符</h3>

<h4 id="whitespace-characters">2.3.1 空白字符</h4>

<p>除换行符外，只允许使用空格 (ASCII 0x20) 作为空白字符。这意味着：</p>

<ol>
<li><p>字符串中的所有其他空白字符必须意转义字符的形式出现。</p></li>
<li><p>禁止使用 tab 进行缩进。</p></li>
</ol>

<h4 id="special-escape-sequences">2.3.2 特殊转义序列</h4>

<p>对所有有专用文字转义表达方式的转义字符 (<code>\'</code>, <code>\"</code>, <code>\\</code>, <code>\b</code>,
<code>\f</code>, <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\v</code>)，只能使用字符转义方式，禁止使用数字转义 (即 <code>\x0a</code>, <code>\u000a</code>, or <code>\u{a}</code>)。禁止使用8进制数字转义。</p>

<h4 id="non-ascii-characters">2.3.3 非 ASCII 字符</h4>

<p>对非 ASCII 字符，要么使用原 Unicode 字符（例如 <code>&#8734;</code> ），要么使用对应的十六进制或者 Unicode 转义 (例如 <code>\u221e</code>)，以使代码易读易理解为选择标准。</p>
</p>

<p class="tip">提示：使用 Unicode 转义，或者直接使用 Unicode 字符时，一段注释说明往往很有帮助。</p>

<table>
  <thead>
    <tr>
      <th>示例
      </th><th>说明
  </th></tr></thead><tbody>
    <tr>
      <td><code class="prettyprint lang-js">const units = '&#956;s';</code>
      </td><td>很好，即使没有注释含义也很清晰。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // '&#956;s'
        </code>
      </td><td>允许这样写，但没有任何理由这样写。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">const units = '\u03bcs'; // Greek letter mu, 's'
        </code>
      </td><td>允许这样写，但很别扭且容易出错。
    </td></tr><tr>
      <td><code class="badcode">const units = '\u03bcs';</code>
      </td><td>很糟糕，读者无法理解这段代码的含义。
    </td></tr><tr>
      <td>
        <code class="prettyprint lang-js">return '\ufeff' + content;  // byte order mark
        </code>
      </td><td>
        很好，针对无法显示的字符使用转义表示，并且添加了必要的注释。
</td></tr></tbody></table>

<p class="tip">提示：千万不要仅仅因为担心其他程序无法正确处理非 ASCII 字符而降低代码可读性。如果确实发生无法处理非 ASCII 字符的情况，那么这是该程序的问题，应该去修复程序。</p>

<h2 id="source-file-structure">3 源文件结构</h2>

<p>一个文件由以下几部分组成：</p>

<ol>
<li>许可证活版权信息，如果有的话</li>
<li>文件概要信息</li>
<li>功能代码</li>
</ol>

<p><strong>每部分之间留一个空行</p>

<h3 id="file-copyright">3.1 许可证活版权信息，如果有的话</h3>

<p></p>

<h3 id="file-fileoverview">3.2 文件概要信息</h3>

<p>格式参照 <a href="#jsdoc-top-file-level-comments">??</a>。</p>

<h3 id="file-goog-module">3.3 <code>goog.module</code> 语句</h3>

<p>所有文件必须包含一个 <code>goog.module</code> 语句。该语句独占一行，不得缩进，不受每行最多80字符的限制。</p>

<p>示例</p>

<pre><code class="language-js prettyprint">goog.module('search.urlHistory.UrlHistoryService');
</code></pre>

<h4 id="naming-hierarchy">3.3.1 层级结构</h4>

<p>模块命名空间之间不允许存在直接父子关系。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">goog.module('foo.bar');   // 'foo.bar.qux' 才是合适的命名
goog.module('foo.bar.baz');
</code></pre>

<p>目录结构应该对应到命名空间结构。这也意味着父命名空间需要知道所有的子命名空间。</p>

<h4 id="file-set-test-only">3.3.2 <code>goog.setTestOnly</code></h4>

<p><code>goog.module</code> 语句后面可以紧跟一个 goog.setTestOnly() 调用</p>

<h4 id="file-declare-legacy-namespace">3.3.3 <code>goog.module.declareLegacyNamespace</code></h4>

<p><code>goog.module</code> 语句后面可以紧跟一个 <code>goog.module.declareLegacyNamespace()</code>调用。尽量减少
<code>goog.module.declareLegacyNamespace()</code> 的使用</p>

<p>示例:</p>

<pre><code class="language-js prettyprint">goog.module('my.test.helpers');
goog.module.declareLegacyNamespace();
goog.setTestOnly();
</code></pre>

<p><code>goog.module.declareLegacyNamespace</code> exists to ease the transition from
traditional object hierarchy-based namespaces but comes with some naming
restrictions. As the child module name must be created after the parent
namespace, this name <strong>must not</strong> be a child or parent of any other
<code>goog.module</code> (for example, <code>goog.module('parent');</code> and
<code>goog.module('parent.child');</code> cannot both exist safely, nor can
<code>goog.module('parent');</code> and <code>goog.module('parent.child.grandchild')</code>).</p>

<h4 id="file-es6-modules">3.3.4 ES6 模块</h4>

<p>不要使用 ES6 模块 (即 <code>export</code> 和 <code>import</code> 关键词)，因为其语义尚未最终确定。注意待其语义标准化之后，该规则会重新进行评估。</p>

<h3 id="file-goog-require">3.4 <code>goog.require</code> 语句</h3>

<p>使用 <code>goog.require</code> 语句导入其他模块，模块导入语句应该作为一组紧跟在模块语句之后。每个 <code>goog.require</code> 被赋值到一个不可变别名上，或者被解构为一组不可变别名。
在代码和类型注解上都必须通过这些别名引用导入的依赖模块，模块的全限定名仅用于作为 <code>goog.require</code> 的参数。别名应该尽量与导入模块模块名按点分隔的最后部分保持一致，
当然也可以为了避免歧义、增强可读性也可以调整。<code>goog.require</code>不能在文件其他地方再次使用。

<p>如果仅为了副作用而导入一个模块，可以不赋值，但该模块的完整限定名不能在文件其他地方出现。同时需要通过注释说明为何需要该模块，并且禁止编译器警告。</p>



<p>模块导入语句排序规则：所有带赋值的语句出现在前面，按照别名字符序排序，解构导入语句也如此。最后是其他独立的 <code>goog.require</code> 调用（通常为了其副作用而导入）。</p>

<p class="tip">提示：不需要记住并且手工执行这条规则，可以使用 IDE 进行 require 顺序检测。</p>

<p>goog.require 代码行禁止换行，可不遵循单行80字符限制。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const MyClass = goog.require('some.package.MyClass');
const NsMyClass = goog.require('other.ns.MyClass');
const googAsserts = goog.require('goog.asserts');
const testingAsserts = goog.require('goog.testing.asserts');
const than80columns = goog.require('pretend.this.is.longer.than80columns');
const {clear, forEach, map} = goog.require('goog.array');
/** @suppress {extraRequire} Initializes MyFramework. */
goog.require('my.framework.initialization');
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js badcode prettyprint">const randomName = goog.require('something.else'); // name must match

const {clear, forEach, map} = // don't break lines
    goog.require('goog.array');

function someFunction() {
  const alias = goog.require('my.long.name.alias'); // must be at top level
  // &#8230;
}
</code></pre>

<h4 id="file-goog-forward-declare">3.4.1 <code>goog.forwardDeclare</code></h4>

<p><code>goog.forwardDeclare</code> 语句不常用，可用于打破循环依赖或者引用延迟加载代码。此类语句统一放到 <code>goog.require</code> 语句后面，代码规范同<code>goog.require</code> 语句。</p>

<h3 id="file-implementation">3.5 代码实现</h3>

<p>代码实现位于依赖声明语句之后，于依赖声明之间至少使用一个空行分隔。</p>

<p>这部分可能包含任何模块局部声明（例如常量，变量，类，函数等），以及任何导出符号。</p>

<h2 id="formatting">4 格式</h2>

<p><strong>术语说明</strong>: <em>块结构</em>是指类、函数、方法或者大括号包含的代码块。Note that, by
<a href="#features-array-literals">??</a> and <a href="#features-object-literals">??</a>, any array or
object literal may optionally be treated as if it were a block-like construct.</p>

<p class="tip">提醒：推荐使用 <code>clang-format</code>。Javascript社区投入很大努力使得 clang-format 可以应用于 Javascript 文件。<code>clang-format</code> 支持多种流行编辑器。</p>

<h3 id="formatting-braces">4.1 大括号</h3>

<h4 id="formatting-braces-all">4.1.1 对所有控制结构使用大括号</h4>

<p>对所有的控制结构使用大括号（例如 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>,
<code>while</code>，等等），即便其中只有一行代码。非空代码块的第一行必须以新行开始。</p>

<p>不规范写法：</p>

<pre><code class="language-js badcode prettyprint">if (someVeryLongCondition())
  doSomething();

for (let i = 0; i &lt; foo.length; i++) bar(foo[i]);
</code></pre>

<p><strong>例外</strong>：如果一个简单的 if 语句能够放在一行内不需要换行，且没有 else 子句，那么为了增强可读性，允许将其放在一行并且不使用大括号。这是唯一一种可以在控制结构中捕食用大括号和换行的情况。</p>

<pre><code class="language-js prettyprint">if (shortCondition()) return;
</code></pre>

<h4 id="formatting-nonempty-blocks">4.1.2 非空代码块：K&amp;R 风格</h4>

<p>所有非空代码块和块结构都需要遵循 Kernighan and Ritchie 风格 (<q><a href="http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html">Egyptian brackets</a></q>)：</p>

<ul>
<li>左大括号前不换行。</li>
<li>左大括号后换行。</li>
<li>右大括号前换行。</li>
<li>如果右大括号标志着一个语句、函数体、类声明、类函数的结束，那么右大括号之后换行。也有例外情况，如果大括号后跟
  <code>else</code>, <code>catch</code>, <code>while</code>，或者逗号、分号、右小括号，那么大括号后不需要换行。</li>
</ul>

<p>示例：</p>

<pre><code class="language-js prettyprint">class InnerClass {
  constructor() {}

  /** @param {number} foo */
  method(foo) {
    if (condition(foo)) {
      try {
        // Note: this might fail.
        something();
      } catch (err) {
        recover();
      }
    }
  }
}
</code></pre>

<h4 id="formatting-empty-blocks">4.1.3 空代码块可以简化</h4>

<p>空代码块或块结构可以简写为 <code>{}</code>，如果其不是一个多代码块语句的一部分（例如 <code>if</code>/<code>else</code> 或者 <code>try</code>/<code>catch</code>/<code>finally</code>）。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function doNothing() {}
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">if (condition) {
  // &#8230;
} else if (otherCondition) {} else {
  // &#8230;
}

try {
  // &#8230;
} catch (e) {}
</code></pre>

<h3 id="formatting-block-indentation">4.2 使用两个空格缩进代码块</h3>

<p>每当产生一个新的代码块或块结构时，代码缩进增加两个空格。代码块结束时，缩进减少两个空格。缩进规则适用于代码和注释。示例参见 <a href="#formatting-nonempty-blocks">??</a>。</p>

<h4 id="formatting-array-literals">4.2.1 数组字面量：可以使用类块风格</h4>

<p>数组字面量可以采用块结构的格式进行格式化。例如以下形式都是合法的（未列出所有情况）：</p>

<pre><code class="language-js prettyprint columns">const a = [
  0,
  1,
  2,
];

const b =
    [0, 1, 2];

</code></pre>

<pre><code class="language-js prettyprint columns">const c = [0, 1, 2];

someMethod(foo, [
  0, 1, 2,
], bar);
</code></pre>

<p>也可以采用其他形式，例如出于强调元素的语义分类的目的，但不应该仅为了减少大数组所占的代码行。</p>

<h4 id="formatting-object-literals">4.2.2 对象字面量：可以使用类块风格</h4>

<p>对象字面量可以采用块结构的格式进行格式化。例如以下形式都是合法的（未列出所有情况）：</p>

<pre><code class="language-js prettyprint columns">const a = {
    a: 0,
    b: 1,
};

const b =
    {a: 0, b: 1};
</code></pre>

<pre><code class="language-js prettyprint columns">const c = {a: 0, b: 1};

someMethod(foo, {
  a: 0, b: 1,
}, bar);
</code></pre>

<h4 id="formatting-class-literals">4.2.3 类字面量</h4>

<p>类字面量（无论是声明还是表达式）参照代码块进行缩进。不要在方法或者声明后添加分号(包含类声明的语句仍要以分号结尾，例如赋值语句)。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint columns">class Foo {
  constructor() {
    /** @type {number} */
    this.x = 42;
  }

  /** @return {number} */
  method() {
    return this.x;
  }
}
Foo.Empty = class {};
</code></pre>

<pre><code class="language-js prettyprint columns">/** @extends {Foo&lt;string&gt;} */
foo.Bar = class extends Foo {
  /** @override */
  method() {
    return super.method() / 2;
  }
};

/** @interface */
class Frobnicator {
  /** @param {string} message */
  frobnicate(message) {}
}
</code></pre>

<h4 id="formatting-function-expressions">4.2.4 函数表达式</h4>

<p>函数调用语句的参数中包含匿名函数时，函数体缩进两个空格。</p>

<p>例子：</p>

<pre><code class="language-js prettyprint">prefix.something.reallyLongFunctionName('whatever', (a1, a2) =&gt; {
  // Indent the function body +2 relative to indentation depth
  // of the 'prefix' statement one line above.
  if (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } else {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});

some.reallyLongFunctionCall(arg1, arg2, arg3)
    .thatsWrapped()
    .then((result) =&gt; {
      // Indent the function body +2 relative to the indentation depth
      // of the '.then()' call.
      if (result) {
        result.use();
      }
    });
</code></pre>

<h4 id="formatting-switch-statements">4.2.5 Switch 语句</h4>

<p>switch 代码块缩进两个空格。</p>

<p>每个 case 标签之后换行，对应标签的处理代码参照块结构进行缩进，如果需要块级作用域可以使用大括号包括处理代码。</p>

<p>break 语句和下一个 case 语句之间可以留一个空行（可选）</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">switch (animal) {
  case Animal.BANDERSNATCH:
    handleBandersnatch();
    break;

  case Animal.JABBERWOCK:
    handleJabberwock();
    break;

  default:
    throw new Error('Unknown animal');
}
</code></pre>

<h3 id="formatting-statements">4.3 语句</h3>

<h4 id="formatting-one-statement-perline">4.3.1 每行一条语句</h4>

<p>每条语句之后都应该换行。</p>

<h4 id="formatting-semicolons-are-required">4.3.2 必须使用分号</h4>

<p>每条语句应该以分号结尾，禁止依赖自动添加分号的功能。</p>

<h3 id="formatting-column-limit">4.4 单行不超过80字符</h3>

<p>一般情况下，单行 JavaScript 代码不得超过80字符，如果超出则断行，参考<a href="#formatting-line-wrapping">??</a>。</p>

<p><strong>例外情况：</strong></p>

<ol>
<li>不可能遵守字符限制的情况，例如一个很长的 URL 字符串。</li>
<li><code>goog.module</code> 以及 <code>goog.require</code> 语句（<a href="#file-goog-module">??</a> 以及
<a href="#file-goog-require">??</a>)）。/li>
</ol>

<h3 id="formatting-line-wrapping">4.5 断行</h3>

<p><strong>术语说明</strong>：<em>断行</em>是指将一个表达式拆分为多行。</p>

<p>没有完备的，确切的的方法告诉你在各种情况下如何断行。同一段代码往往有多种断行方式。</p>

<p>注意：尽管断行一般是为了不超出单行字符数的限制，但开发人员也可以出于其他原因自行决定断行。</p>

<p>提示：可以通过将部分内容提取为一个函数或据不变量的方法来避免断行。</p>

<h4 id="formatting-where-to-break">4.5.1 从何处断行</h4>

<p>原则上尽量依照高层语义进行断行。</strong>. </p>

<p>推荐方案：</p>

<pre><code class="language-js prettyprint">currentEstimate =
    calc(currentEstimate + x * currentEstimate) /
        2.0f;
</code></pre>

<p>不推荐：</p>

<pre><code class="language-js prettyprint badcode">currentEstimate = calc(currentEstimate + x *
    currentEstimate) / 2.0f;
</code></pre>

<p>上例中，语义从高到低依次是赋值、除法、函数调用、参数、数字常量。</p>

<p>操作符断行规则：</p>

<ol>
<li>在操作符之后断行
<ol>
<li>该规则不适用于 <q>点</q> (<code>.</code>)，点本身不是操作符。</li>
</ol></li>
<li>函数或者构造函数名名与其左括号（<code>(</code>）写在一起。</li>
<li>逗号（<code>,</code>）前不断行。</li>
</ol>

<blockquote>
<p>注意：断行的主要目的是使代码清晰易读。The primary goal for line wrapping is to have clear code, not
necessarily code that fits in the smallest number of lines.</p>
</blockquote>

<h4 id="formatting-indent">4.5.2 延续行缩进至少四个空格</h4>

<p>发生断行时，除第一行的其他行（所谓延续行）相对于第一行至少缩进四个空格，unless it falls under the rules of
block indentation.</p>

<p>右多个延续行时，每行的缩进可能不同。一般来说，较深语义层次的代码行缩进更多，缩进量都是4的整倍数。两行缩进相同当且仅当他们的语义层次相同。</p>

<p><a href="#formatting-horizontal-alignment">??</a> 描述了通过使用不同个数的空格来对齐上下行的特定词句的情况，这是不推荐的。</p>

<h3 id="formatting-whitespace">4.6 空白</h3>

<h4 id="formatting-vertical-whitespace">4.6.1 空行</h4>

<p>单个空行在以下情况下出现：</p>

<ol>
<li>在类或对象字面量的连续两个函数定义之间。
<ol>
<li>例外：对象字面量的两个连续属性定义之间的空行是可选的，这种空行常用于字段分组。</li>
</ol></li>
<li>空行可以用于在函数内部划分逻辑块，蛋不允许以空行开始或结尾。</li>
<li>类、对象字面量的第一个函数之前或者最后一个函数之后可以有一个空行（不推荐，也不反对）。</li>
<li>文档中列举的其他情况（例如<a href="#file-goog-require">??</a>）。</li>
</ol>

<p>多个连续空行也是允许的，但不要求，也不反对。</p>

<h4 id="formatting-horizontal-whitespace">4.6.2 行内空白</h4>

<p>行内空格的使用可以分为三种情况：行首、行尾、行内。行首空白（也就是缩进）其他章节已讲过，行为空白是不允许的。</p>

<p>除了语言本身要求或其他规范要求，以及字面量、注释、JSDoc之外，空白字符<em>仅</em>在以下情况下使用：</p>

<ol>
<li>分隔保留字（例如 <code>if</code>, <code>for</code>, <code>catch</code>）和之后的左括号（<code>(</code>）。</li>
<li>分隔保留字（例如 <code>else</code>, <code>catch</code>）和之前的右大括号（<code>}</code>）。</li>
<li>用于所有左大括号（<code>{</code>）之前，除以下例外情况：
<ol>
<li>当一个对象字面量作为函数的第一个参数或者数组字面量的第一个元素时（例如 <code>foo({a: [{c: d}]})</code> ），在对象字面量之前添加空格。</li>
<li>在模板扩展代码中，因为模板语法不允许（例如 <code>abc${1 + 2}def</code> ）。</li>
</ol></li>
<li>在二元或者三元操作符前后。</li>
<li>在逗号（<code>,</code>）或分号（<code>;</code>）之后。注意这些符号前不允许有空格。</li>
<li>对象字面量的冒号（<code>:</code>）之后。</li>
<li>在双斜线（<code>//</code>，行内注释）前后。此处也可以使用多个空格。</li>
<li>在 JSDoc 起始注释字符之后，以及结束字符前后（例如简短的类型声明或者赋值： <code>this.foo = /** @type
{number} */ (bar);</code> or <code>function(/** string */ foo) {</code>）。</li>
</ol>

<h4 id="formatting-horizontal-alignment">4.6.3 不建议水平对齐</h4>

<p><strong>术语说明</strong>: <em>水平对齐</em>是指通过在代码中添加不同数量的空格，使得前后代码行中的特定词语纵向对齐。</p>

<p>允许这种做法，但并不推荐。</p>

<p>下面一个是不对齐的例子，一个对齐的示例。两者都允许，但不推荐后者。</p>

<pre><code class="language-js prettyprint">{
  tiny: 42, // this is great
  longer: 435, // this too
};

{
  tiny:   42,  // permitted, but future edits
  longer: 435, // may leave it unaligned
};
</code></pre>

<p>注意：对齐有助于可读性，但不利于后续维护。考虑一个后续的修改只涉及其中一行，但为了代码对齐可能需要修改很多行代码格式。最坏情况下这可能导致无意义的忙碌，最好情况下也会破坏版本信息，降低代码 review 和代码冲突处理效率。</p>

<h4 id="formatting-function-arguments">4.6.4 函数参数</h4>

<p>推荐将函数参数与函数名写在同一行。如果超出单行字符限制断行时，必须考虑可读性。可以尽量在80字符处断行以节约空间，也可以每个参数一行增强可读性。应该缩进四个空格。也可以按照括号对齐，但不推荐这种做法。下面是常用的参数断行方式：</p>

<pre><code class="language-js prettyprint">// Arguments start on a new line, indented four spaces. Preferred when the
// arguments don't fit on the same line with the function name (or the keyword
// "function") but fit entirely on the second line. Works with very long
// function names, survives renaming without reindenting, low on space.
doSomething(
    descriptiveArgumentOne, descriptiveArgumentTwo, descriptiveArgumentThree) {
  // &#8230;
}

// If the argument list is longer, wrap at 80. Uses less vertical space,
// but violates the rectangle rule and is thus not recommended.
doSomething(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
  // &#8230;
}

// Four-space, one argument per line.  Works with long function names,
// survives renaming, and emphasizes each argument.
doSomething(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
  // &#8230;
}
</code></pre>

<h3 id="formatting-grouping-parentheses">4.7 推荐使用括号进行分组</h3>

<p>使用括号在表达式中进行分组时有益的。除非开发人员和评审人员都认为没有括号不会导致任何误解，对代码可读性也没有帮助，否则建议使用括号。不可能所有开发人员都牢记所有运算符优先级。</p>

<p>不要用括号把<code>delete</code>，<code>typeof</code>，<code>void</code>，<code>return</code>，<code>throw</code>，<code>case</code>，<code>in</code>，<code>of</code>，或者 <code>yield</code> 之后的表达式整个包括起来，这完全没必要。</p>

<p>类型转换必须使用括号：<code>/** @type {!Foo} */ (foo)</code>。</p>

<h3 id="formatting-comments">4.8 注释</h3>

<h4 id="formatting-block-comment-style">4.8.1 注释</h4>

<p>注释与同级代码缩进保持一致，可以是 <code>/* &#8230; */</code> 或者 <code>//</code> 的形式。
  多行注释 <code>/* &#8230; */</code>，除第一行之外必须以 * 开头，且与第一行的 * 对齐。
  如果函数调用中函数名和参数值含义不明确，可以在参数值之后补充注释。</p>

<pre><code class="language-js prettyprint">/*
 * This is
 * okay.
 */

// And so
// is this.

/* This is fine, too. */

someFunction(obviousParam, true /* shouldRender */, 'hello' /* name */);
</code></pre>

<p>注释不要包括在星号或者其他字符绘制的框中。</p>

<p>在实现注释中不要使用文档注释 JSDoc (<code>/** &#8230; */</code>).</p>

<h2 id="language-features">5 语言特性</h2>

<p>JavaScript 有许多有风险的，甚至危险的特性。本节描述了哪些特性可以使用，那些不推荐使用，以及相关的使用限制。</p>

<h3 id="features-local-variable-declarations">5.1 局部变量声明</h3>

<h4 id="features-use-const-and-let">5.1.1 使用 <code>const</code> 以及 <code>let</code></h4>

<p>使用 <code>const</code> 或者 <code>let</code> 声明所有的局部变量。默认使用 <code>const</code>，除非变量会被再次赋值。禁止使用 <code>var</code>。</p>

<h4 id="features-one-variable-per-declaration">5.1.2 每个声明仅含一个变量</h4>

<p>每个局部变量声明仅包含一个变量，不允许类似 <code class="badcode">let a = 1, b = 2;</code> 的用法。</p>

<h4 id="features-declared-when-needed">5.1.3 按需声明，尽快初始化</h4>

<p>无需将局部变量声明统一写在代码块块起始位置，而应该在初次使用时声明，以使其作用范围最小化。</p>

<h4 id="features-declare-types-as-needed">5.1.4 按需声明类型</h4>

<p>JSDoc 类型注释可以写在类型声明上一行，也可以在行内，写在变量名之前。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const /** !Array&lt;number&gt; */ data = [];

/** @type {!Array&lt;number&gt;} */
const data = [];
</code></pre>

<p>提示：: 许多情况下编译器可以推断模板类型，但无法推断其参数类型，例如初始化字面量或者初始化函数不包含任何模板参数类型信息时（例如空数组，对象，<code>Map</code>，<code>Set</code>）。
这种情况下变量类型注释会很有用。</p>

<h3 id="features-array-literals">5.2 数组字面量</h3>

<h4 id="features-arrays-trailing-comma">5.2.1 尾元素后使用逗号</h4>

<p>最后一个元素与结尾中括号之间换行时，尾元素之后始终添加一个逗号。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const values = [
  'first value',
  'second value',
];
</code></pre>

<h4 id="features-arrays-ctor">5.2.2 不要使用可变参数的 <code>Array</code> 构造函数</h4>

<p>当添加或删除参数时，该构造函数很容易带来问题。使用字面量的方式初始化。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">const a1 = new Array(x1, x2, x3);
const a2 = new Array(x1, x2);
const a3 = new Array(x1);
const a4 = new Array();
</code></pre>

<p>第三行代码会导致如下问题：如果<code>x1</code>是个整数，那么<code>a3</code>会是一个长度等于<code>x1</code>的数组，元素均为<code>undefined</code>。
如果<code>x1</code>是其他数字，那么会产生异常。其他情况下会生成一个单元素的数组。</p>

<p>应该使用这种写法：</p>

<pre><code class="language-js prettyprint">const a1 = [x1, x2, x3];
const a2 = [x1, x2];
const a3 = [x1];
const a4 = [];
</code></pre>

<p>如果需要，也可以使用 <code>new Array(length)</code> 显示分配一个特定长度的数组。</p>

<h4 id="features-arrays-non-numeric-properties">5.2.3 非数字属性</h4>

<p>不要在数组上定义或者使用非数字属性（除了<code>length</code>），使用<code>Map</code>或者<code>Object</code>。</p>

<h4 id="features-arrays-destructuring">5.2.4 解构</h4>

<p>解构赋值语法常用作赋值语句的左值（例如从一个数组中提取多个值）。结尾处可以包含一个<q>rest</q>元素（<code>...</code>和rest变量名之间不要有空格）。不需要的元素应该被忽略。</p>

<pre><code class="language-js prettyprint">const [a, b, c, ...rest] = generateResults();
let [, b,, d] = someArray;
</code></pre>

<p>解构语法也可以用于函数参数。如果数据参数是可选择，那么使用提供<code>[]</code>作为默认值，并且在左侧提供相应参数默认值：</p>

<pre><code class="language-js prettyprint">/** @param {!Array&lt;number&gt;=} param1 */
function optionalDestructuring([a = 4, b = 2] = []) { &#8230; };
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">function badDestructuring([a, b] = [4, 2]) { &#8230; };
</code></pre>

<p>提示：将函数参数或者返回值包装为一个变量时，推荐使用对象而不是数组，因为可以为变量元素指定名称并且每个元素类型可以不同。</p>

<h4 id="features-arrays-spread-operator">5.2.5 扩展操作符</h4>

<p>数组字面量内可以使用扩展操作符<code>...</code>从一个或者多个其他值中提取元素，使用扩展操作符而不要使用<code>Array.prototype</code>上的方法进行元素提取操作。<code>...</code>之后不要有空格。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">[...foo]   // 优于 Array.prototype.slice.call(foo)
[...foo, ...bar]   // 优于 foo.concat(bar)
</code></pre>

<h3 id="features-object-literals">5.3 对象字面量</h3>

<h4 id="features-objects-use-trailing-comma">5.3.1 尾元素后使用逗号</h4>

<p>最后一个元素与结尾大括号之间换行时，尾元素之后始终添加一个逗号。</p>

<h4 id="features-objects-ctor">5.3.2 不要使用<code>Object</code>构造函数</h4>

<p>尽管<code>Object</code>构造函数没有<code>Array</code>的问题，但出于一致性考虑，仍然不推荐该用法，使用对象字面量进行初始化，例如<code>{}</code> 或者 <code>{a: 0, b: 1, c: 2}</code>。</p>

<h4 id="features-objects-mixing-keys">5.3.3 不要混用加引号和不加引号的键</h4>

<p>对象字面量可以使用不加引号的键或者符号表示结构体，也可以使用加引号或者计算出的键表示字典。不要再单个对象字面量中混用这些键类型。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">{
  a: 42, // 结构体类型的不加引号的键
  'b': 43, // 字典类型的加引号的键
}
</code></pre>

<h4 id="features-objects-computed-property-names">5.3.4 计算属性名</h4>

<p>允许使用计算属性名（例如<code>{['key' + foo()]: 42}</code>）。计算属性名术语字典类型的键（意味着其不能与不加引号的键混用），除非该计算属性是一个 symbol（例如<code>[Symbol.iterator]</code>）。
 枚举值也可以用作计算属性，但不应该同其他非枚举键混用。</p>

<h4 id="features-objects-method-shorthand">5.3.5 方法简写</h4>

<p>对象字面量中的方法定义可以简写，例如：</p>

<pre><code class="language-js prettyprint">return {
  stuff: 'candy',
  method() {
    return this.stuff;  // Returns 'candy'
  },
};
</code></pre>

<p>注意方法简写或者函数中的<code>this</code>指向对象字面量自身，而箭头函数中的<code>this</code>则与对象字面量外部作用域的<code>this</code>保持一致。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">class {
  getObjectLiteral() {
    this.stuff = 'fruit';
    return {
      stuff: 'candy',
      method: () =&gt; this.stuff,  // Returns 'fruit'
    };
  }
}
</code></pre>

<h4 id="features-objects-shorthand-properties">5.3.6 属性简写</h4>

<p>可以在对象字面量中使用属性简写，例如：</p>

<pre><code class="language-js prettyprint">const foo = 1;
const bar = 2;
const obj = {
  foo,
  bar,
  method() { return this.foo + this.bar; },
};
assertEquals(3, obj.method());
</code></pre>

<h4 id="features-objects-destructuring">5.3.7 对象结构</h4>

<p>对象解构语法常用作赋值语句的左值，用于从单个对象中提取多个值。</p>

<p>解构对象也用于函数参数，但用法应该尽量简单，只使用单层不加引号的属性简写。不建议在参数解构中使用多层或者计算属性。
在参数解构语句的左值为参数指定默认值，例如<code>{str = 'some default'} = {}</code>而不是<code class="badcode">{str} = {str: 'some default'}</code>。
如果解构对象本身时可选的，那么必须指定默认值<code>{}</code>。JSDoc中可以为解构参数指定任何名字（该名字并不实际使用，但编译器要求提供）。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} ordinary
 * @param {{num: (number|undefined), str: (string|undefined)}=} param1
 *     num: The number of times to do something.
 *     str: A string to do stuff to.
 */
function destructured(ordinary, {num, str = 'some default'} = {})
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">/** @param {{x: {num: (number|undefined), str: (string|undefined)}}} param1 */
function nestedTooDeeply({x: {num, str}}) {};
/** @param {{num: (number|undefined), str: (string|undefined)}=} param1 */
function nonShorthandProperty({num: a, str: b} = {}) {};
/** @param {{a: number, b: number}} param1 */
function computedKey({a, b, [a + b]: c}) {};
/** @param {{a: number, b: string}=} param1 */
function nontrivialDefault({a, b} = {a: 2, b: 4}) {};
</code></pre>

<p>解构语法也可以用于<code>goog.require</code>语句，此时不允许断行（见<a href="#file-goog-require">??</a>）。</p>

<h4 id="features-objects-enums">5.3.8 枚举</h4>

<p>通过在对象字面量上添加<code>@enum</code>注解来定义枚举。枚举定义后，不允许再添加属性。枚举必须是常量，所有枚举值必须是必须是不递归可变的。</p>

<pre><code class="language-js prettyprint">/**
 * 所支持的温标
 * @enum {string}
 */
const TemperatureScale = {
  CELSIUS: 'celsius',
  FAHRENHEIT: 'fahrenheit',
};

/**
 * 两个选项的枚举。
 * @enum {number}
 */
const Option = {
  /** 该选项必须是第一个 */
  FIRST_OPTION: 1,
  /** 第二个选项 */
  SECOND_OPTION: 2,
};
</code></pre>

<h3 id="features-classes">5.4 类</h3>

<h4 id="features-classes-constructors">5.4.1 构造函数</h4>

<p>具体类（concrete class）的构造函数是可选的。子类构造函数在访问<code>this</code>或者设置字段（fields）之前，必须先调用<code>super()</code>。接口不允许定义构造函数。</p>

<h4 id="features-classes-fields">5.4.2 字段（Fields）</h4>

<p>必须在构造函数中设置所有对象字段（即除了方法之外的所有属性）的值。
  给所有不变的字段添加<code>@const</code>注解（字段内容必须是深层不可变的 deeply immutable）。
  私有字段必须天津爱<code>@private</code>注解，名称必须以下划线结尾。
  不允许设置具体类（concrete class）原型的字段。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">class Foo {
  constructor() {
    /** @private @const {!Bar} */
    this.bar_ = computeBar();
  }
}
</code></pre>

<p>提示：构造函数执行结束后，不允许在对象实例上添加或者删除属性，这会严重影响虚拟机的优化能力。
  如果确实有属性要延后初始化，在构造函数中将其设置为<code>undefined</code>。</p>

<h4 id="features-classes-computed-properties">5.4.3 计算属性</h4>

<p>只允许对 symbol 属性使用子酸属性。不幸允许使用字典类型的属性（见 <a href="#features-objects-mixing-keys">??</a>）。
  对可枚举的类需要定义<code>[Symbol.iterator]</code>方法。除此之外，<code>Symbol</code> 应该慎用。</p>

<p>提示：慎用其他内置 symbol（<code>Symbol.isConcatSpreadable</code>等），旧浏览器可能不支持。</p>

<h4 id="features-classes-static-methods">5.4.4 静态方法</h4>

<p>在不影响可读性的情况下，建议使用模块内局部函数而不会死私有静态方法。</p>

<p>静态函数只能在其定义所属的类上调用。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">class Base { /** @nocollapse */ static foo() {} }
class Sub extends Base {}
function callFoo(cls) { cls.foo(); }  // 不推荐：不要以动态方式调用静态函数
Sub.foo();  // 非法使用：Sub自身没有定义foo静态方法，禁止这种用法
</code></pre>

<h4 id="features-classes-old-style">5.4.5 老式类定义</h4>

<p>尽管更推荐使用 ES6 的类定义方式，但一些情况下无法使用 ES6 的方式，例如：</p>

<ol>
<li><p>框架代码中的类被继承产生了子类，而这些子类无法立即使用 ES6 语法重写。如果父类切换到 ES6 语法，所有子类也必须修改。</p></li>
<li><p>在调用父类构造函数之前就需要使用 <code>this</code> 的情况。原因是 ES6 的父类构造函数调用<code>super</code>执行结束之前，不能访问<code>this</code>变量。</p></li>
</ol>

<p>同样，合适的情况下推荐使用<code>let</code>，<code>const</code>，默认参数，剩余参数，箭头函数。</p>

<p>类实例的属性应该在构造函数中进行设置，方法应该在构造函数原型上定义。</p>

<h4 id="features-classes-prototypes">5.4.6 尽量不要直接操作<code>prototype</code>s</h4>

<p>使用<code>class</code>关键词定义类比<code>prototype</code>的方式更简洁，可读性更强。一般代码不需要使用<code>prototype</code>。
  禁止在内置对象上使用混入（Mixin）或者修改内置对象原型。</p>

<p><strong>例外</strong>：框架代码（例如Polymer, Angular）可能仍要使用<code>prototype</code>s，以避免更糟糕的解决方案。</p>

<p><strong>例外</strong>：在接口上定义字段（见 <a href="#features-classes-interfaces">??</a>）。</p>

<h4 id="features-classes-getters-and-setters">5.4.7 Getters & Setters</h4>

<p>不要使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">JavaScript getter 和 setter 属性</a>。
  getter 和 setter 有一些奇怪而难以理解的特性，并且编译器对其支持有限。推荐使用普通方法。</p>

<p><strong>例外</strong>：在数据绑定框架（例如Angular，Polymer）中可以少量使用getter和setter，
  并且要用 <code>get foo()</code> 、 <code>set foo(value)</code>，或者 <code>Object.defineProperties</code> 的形式，
  不要使用 <code>Object.defineProperty</code>，因为其函数名容易与属性重命名混淆。Getters 中不允许修改可观测状态。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">class Foo {
  get next() { return this.nextId++; }
}
</code></pre>

<h4 id="features-classes-overriding-tostring">5.4.8 重载 toString</h4>

<p>可以按需重载 <code>toString</code> 方法，但该方法必须始终成功，且不能有可见的副作用。</p>

<p>提示：尤其要注意在 toString 中调用其他函数的情况，因为特定情况下可能导致死循环。</p>

<h4 id="features-classes-interfaces">5.4.9 接口</h4>

<p>使用<code>@interface</code> 或者 <code>@record</code>注解来声明接口。</p>

<p>接口上的非静态方法必须是空方法。接口字段必须在<code>prototype</code>上定义。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * Something that can frobnicate.
 * @record
 */
class Frobnicator {
  /**
   * Performs the frobnication according to the given strategy.
   * @param {!FrobnicationStrategy} strategy
   */
  frobnicate(strategy) {}
}

/** @type {number} The number of attempts before giving up. */
Frobnicator.prototype.attempts;
</code></pre>

<h3 id="features-functions">5.5 函数</h3>

<h4 id="features-functions-top-level-functions">5.5.1 顶级函数</h4>

<p>导出函数可以直接在<code>export</code>对象上定义，也可以声明然后另外导出。鼓励使用非导出函数，不需要使用<code>@private</code>注解。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/** @return {number} */
function helperFunction() {
  return 42;
}
/** @return {number} */
function exportedFunction() {
  return helperFunction() * 2;
}
/**
 * @param {string} arg
 * @return {number}
 */
function anotherExportedFunction(arg) {
  return helperFunction() / arg.length;
}
/** @const */
exports = {exportedFunction, anotherExportedFunction};
</code></pre>

<pre><code class="language-js prettyprint">/** @param {string} arg */
exports.foo = (arg) =&gt; {
  // do some stuff ...
};
</code></pre>

<h4 id="features-functions-nested-functions">5.5.2 嵌套函数与闭包</h4>

<p>函数中可以包含嵌套函数定义。只能将函数赋给一个常量。</p>

<h4 id="features-functions-arrow-functions">5.5.3 箭头函数</h4>

<p>箭头函数语法简介，并且解决了<code>this</code>的一些难题。优先使用箭头函数而不是<code>function</code>关键词，尤其是定义嵌套函数时（例外情况见 <a href="#features-objects-method-shorthand">??</a>）。</p>

<p>推荐使用箭头函数而不是 <code>f.bind(this)</code>。避免<code>const self = this</code>的写法。回调函数有时会传递一些意料之外的参数，箭头函数在这种情况下尤其有用。</p>

<p>箭头函数右侧部分可以是表达式或是代码块。如果箭头函数只有一个非结构参数，参数外围的圆括号是可选的。</p>

<p>提示：始终使用圆括号包括参数是个好习惯，因为如果没有括号，可能后续添加了一个参数但漏了括号，此时代码不会报错，但结果是错的。</p>

<h4 id="features-functions-generators">5.5.4 生成器函数（Generators）</h4>

<p>生成器函数提供了一些高级抽象特征，可以按需使用。</p>

<p>定义生成器函数时，<code>*</code>符号紧贴在<code>function</code>关键词后，与函数名之前用一个空格分隔。
  使用代理yield（delegating yield）时，<code>*</code>符号紧贴在<code>yield</code>关键词后。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/** @return {!Iterator&lt;number&gt;} */
function* gen1() {
  yield 42;
}

/** @return {!Iterator&lt;number&gt;} */
const gen2 = function*() {
  yield* gen1();
}

class SomeClass {
  /** @return {!Iterator&lt;number&gt;} */
  * gen() {
    yield 42;
  }
}
</code></pre>

<h4 id="features-functions-parameters">5.5.5 参数</h4>

<p>在书定义前必须使用JSDoc注解声明所有函数参数类型。使用<code>@override</code>注解重写相同签名的父类函数时，可以忽略参数类型声明。</p>

<p>也可以在行内声明参数类型（例如<code>(/** number */ foo, /** string */ bar) =&gt; foo + bar</code>）。同一个函数上行内声明和<code>@param</code>形式的类型注解不能混合使用。</p>

<h5 id="features-functions-default-parameters">5.5.5.1 默认参数</h5>

<p>可选参数出现在必填参数之后，命名与其他参数相同（不要使用<code>opt_</code>前缀等），必须指定默认值（即使默认值是<code>undefined</code>），等号前后各一个空格。
  在JSDoc中使用<code>=</code>进行类型声明。默认值初始化不能产生副作用。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {string} required - 必填参数
 * @param {string=} optional - 该参数可忽略
 * @param {!Node=} node - 另一个可忽略的参数
 */
function maybeDoSomething(required, optional = '', node = undefined) {}
</code></pre>

<p>如果有多个可选参数，且之间没有明确的顺序，优先使用解构语法（<a href="#features-objects-destructuring">??</a>）</p>

<p>注意：与Python不同的是，javascript参数默认值中初始化对象（例如<code>{}</code> 或者 <code>[]</code>）是安全的，
  因为每次应用参数默认值时默认值初始化方法都会执行，因此不同的调用之间不会共用一个对象。</p>

<p>提示：尽管包括函数调用之内的任意表达式都可以用于默认值初始化，但初始化方式应该尽量简单。应该尽量避免初始化默认值中使用共享的可变状态，这可能会导致不同的函数调用之间产生耦合。</p>

<h5 id="features-functions-rest-parameters">5.5.5.2 剩余参数</h5>

<p>不要使用<code>arguments</code>，使用剩余参数。JSDoc中使用<code>...</code>声明剩余参数的类型。
  剩余参数必须是参数列表中的最后一个参数。<code>...</code>和参数名之间不能有空格。不要将其命名为<code>var_args</code>。
  不要将局部变量或者参数命名为<code>arguments</code>，以免与内置变量混淆。
  Use a <em>rest</em> parameter instead of accessing <code>arguments</code>. Rest parameters are
typed with a <code>...</code> prefix in their JSDoc. The rest parameter must be the last
parameter in the list. There is no space between the <code>...</code> and the parameter
name.  Do not name the rest parameter <code>var_args</code>. Never name a local variable or
parameter <code>arguments</code>, which confusingly shadows the built-in name.</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">/**
 * @param {!Array&lt;string&gt;} array - 普通参数
 * @param {...number} numbers 剩余的参数都是数字
 */
function variadic(array, ...numbers) {}
</code></pre>

<h4 id="features-functions-returns">5.5.6 返回值</h4>

<p>必须在函数JSDoc注释中声明返回值类型，使用<code>@override</code>注解重写相同签名的父类函数时，可以忽略类型声明。</p>

<h4 id="features-functions-generics">5.5.7 泛型</h4>

<p>声明泛型函数时，在JSDoc中使用 <code>@template TYPE</code> 进行声明</p>

<h4 id="features-functions-spread-operator">5.5.8 扩展操作符（Spread operator）</h4>

<p>可以在调用函数时使用扩展操作符<code>...</code>。
  需要将数组或可枚举对象解析为可变长参数函数（variadic function）的多个参数时，推荐使用扩展操作符而不是<code>Function.prototype.apply</code>。
  <code>...</code>之后不要添加空格。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function myFunction(...elements) {}
myFunction(...array, ...iterable, ...generator());
</code></pre>

<h3 id="features-string-literals">5.6 字符串字面量</h3>

<h4 id="features-strings-use-single-quotes">5.6.1 使用单引号</h4>

<p>使用单引号（<code>'</code>）包括普通字符串字面量，不要使用双引号（<code>"</code>）。</p>

<p>提示：如果字符串中包含单引号，考虑使用模板字符串，以避免使用转义。</p>

<p>普通字符串字面量不能跨行。</p>

<h4 id="features-strings-template-strings">5.6.2 模板字符串</h4>

<p>使用模板字符串不要使用复杂的子字符串拼接，尤其是涉及多个字符串字面量时。模板字符串可以跨行。</p>

<p>模板字符串跨多行时，不需要遵循其所在块的缩进。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">function arithmetic(a, b) {
  return `Here is a table of arithmetic operations:
${a} + ${b} = ${a + b}
${a} - ${b} = ${a - b}
${a} * ${b} = ${a * b}
${a} / ${b} = ${a / b}`;
}
</code></pre>

<h4 id="features-strings-no-line-continuations">5.6.3 不要使用续行符（line continuations）</h4>

<p>无论在普通字符串还是模板字符串中都不要使用续行符。如果反斜线之后有空白会很难观察，这可能会导致难以发觉的错误。</p>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">const longString = 'This is a very long string that far exceeds the 80 \
    column limit. It unfortunately contains long stretches of spaces due \
    to how the continued lines are indented.';
</code></pre>

<p>推荐写法：</p>

<pre><code class="language-js prettyprint">const longString = 'This is a very long string that far exceeds the 80 ' +
    'column limit. It does not contain long stretches of spaces since ' +
    'the concatenated strings are cleaner.';
</code></pre>

<h3 id="features-number-literals">5.7 数字字面量</h3>

<p>可以使用十进制，十六进制，八进制，或者二进制形式的数字。对十六进制、八进制、二进制数字时分别添加小写 <code>0x</code>,
<code>0o</code>, and <code>0b</code> 前缀。非前缀部分不要以0开头。</p>

<h3 id="features-control-structures">5.8 控制解构</h3>

<h4 id="features-for-loops">5.8.1 For 循环</h4>

<p>ES6语法包含三种形式的<code>for</code>循环。三种均可使用，其中更推荐<code>for</code>-<code>of</code>形式。</p>

<p><code>for</code>-<code>in</code> 循环只能用于字典风格的对象（见<a href="#features-objects-mixing-keys">??</a>），
  不能用于遍历数组。可以在<code>for</code>-<code>in</code>循环中使用<code>Object.prototype.hasOwnProperty</code>以过滤掉原型上的属性。
  推荐使用<code>for</code>-<code>of</code>和<code>Object.keys</code>而不要使用<code>for</code>-<code>in</code>。</p>

<h4 id="features-exceptions">5.8.2 异常</h4>

<p>异常是javascript语言的重要组成部分。在发生意外情况时，始终抛出<code>Error</code对象或者其子类对象，不要直接抛出字符串或者其他对象。
  使用<code>new</code>>操作符构在<code>Error</code>对象。</p>

<p>自定义异常对象可以提供额外的错误信息，当内置<code>Error</code>类型不能满足需求时建议使用自定义对象。</p>

<p>需要时推荐抛出异常而不是使用自定义的错误处理机制（例如返回数据中包含一个是否发生错误的属性）。</p>

<h5 id="features-empty-catch-blocks">5.8.2.1 空 catch 块</h5>

<p>大部分情况下在异常处理代码块中不做任何处理是有问题的。如果确实要这么做，在注释中写一下原因。</p>

<pre><code class="language-js prettyprint">try {
  return handleNumericResponse(response);
} catch (ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
</code></pre>

<p>不规范写法：</p>

<pre><code class="language-js prettyprint badcode">   try {
    shouldFail();
    fail('expected an error');
  }
  catch (expected) {}
</code></pre>

<p>提示：上面代码在javascript中的行为与其他语言不太相同，因为javascript没有指定参数类型的机制，
  不会判断异常实例是否是catch子句中指定的类型，因此<code>fail</code>抛出的异常始终会被捕获。
  如果有根据类型进行处理的需求可以使用<code>assert.throws</code>。</p>

<h4 id="features-switch-statements">5.8.3 Switch 语句</h4>

<p>术语说明：switch代码块内部包含一个或多个语句组，每个语句组包含一个或多个switch标签（<code>case FOO:</code> 或 <code>default:</code>），后跟一个或多个语句。</p>

<h5 id="features-switch-fall-through">5.8.3.1 fall-through</h5>

<p>switch语句中的每个语句组要么显示结束（以<code>break</code>，<code>return</code>，或者<code>throw</code>的形式），
  要么添加注释说明会继续执行下一个语句组中的代码（例如<code>// fall through</code>）。最后一个语句组不需要添加该注释。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
  // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
</code></pre>

<h5 id="features-switch-default-case">5.8.3.2 始终添加 <code>default</code> 语句组</h5>

<p>每个switch表达式都要包含一个<code>default</code>语句组，即使其中没有任何处理逻辑。</p>

<h3 id="features-this">5.9 this</h3>

<p>只在类构造函数或方法，或者其内部的箭头函数中使用<code>this</code>。其他情况下使用<code>this</code>时必须在其最近的函数JSDoc中对<code>this</code>进行声明。</p>

<p>不要使用<code>this</code>引用全局对象，<code>eval</code>的上下文，事件（event）关联的对象（target），或者使用<code>call()</code>或者<code>apply()</code>调用的函数。</p>

<h3 id="disallowed-features">5.10 禁止使用的特性</h3>

<h4 id="disallowed-features-with">5.10.1 with</h4>

<p>不要使用<code>with</code>关键词，该特性不利于代码可读性，在ES5严格模式中已经被禁止使用。</p>

<h4 id="disallowed-features-dynamic-code-evaluation">5.10.2 动态执行代码</h4>

<p>不要使用<code>eval</code>或者<code>Function(...string)</code>构造函数（除了用于代码加载工具中），这些特性存在潜在的危险性。</p>

<h4 id="disallowed-features-automatic-semicolon-insertion">5.10.3 自动插入分号</h4>

<p>除了函数和类声明之外，所有语句一律以分号结尾。</p>

<h4 id="disallowed-features-non-standard-features">5.10.4 非标准特性</h4>

<p>不要使用非标准特性，包括已删除的功能（例如<code>WeakMap.clear</code>），尚未标准化的新特性（当前的TC39草案，各阶段提案，或者提出但尚未完成的web标准），
  或者部分浏览器的专利特性。只使用当前ECMA-262或者WHATWG标准中包含的特性。当然专为Node.js或者Chrome扩展所写的代码不受该限制约束。禁止使用非标准语言扩展。</p>

<h4 id="disallowed-features-wrapper-objects">5.10.5 原生类型对象封装</h4>

<p>不要在原生类型对象封装（例如<code>Boolean</code>, <code>Number</code>, <code>String</code>,
  <code>Symbol</code>）上使用<code>new</code>操作符，也不要再类型注解中使用原生类型对象封装。</p>

<p>不规范用法：</p>

<pre><code class="language-js prettyprint badcode">const /** Boolean */ x = new Boolean(false);
if (x) alert(typeof x);  // alerts 'object' - WAT?
</code></pre>

<p>原生类型对象封装一般用于强制类型转换或者创建symbols。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const /** boolean */ x = Boolean(0);
if (!x) alert(typeof x);  // alerts 'boolean', as expected
</code></pre>

<h4 id="disallowed-features-modifying-builtin-objects">5.10.6 修改内建对象</h4>

<p>不要修改内建类型，也不要依赖有这种行为的库。</p>

<h2 id="naming">6 命名</h2>

<h3 id="naming-rules-common-to-all-identifiers">6.1 标志符（Identifier）通用规则</h3>

<p>标志符中只能使用ASCII字符和数字，在下面所列的少数情况下可以使用下划线和美元符号。</p>

<p>标志符命名尽量是自描述的。不要考虑缩短命名以节省空间，让其他人能够迅速理解代码要重要的多。
  不要使用项目外其他人不理解或者不熟悉的缩写，不要以删除单词中间字符的方式进行缩写。</p>

<pre><code class="language-js prettyprint">priceCountReader      // 不要使用缩写
numErrors             // "num" 是广泛使用的惯例用法
numDnsConnections     // 大部分人都明白Dns的含义
</code></pre>

<p>不规范用法：</p>

<pre><code class="language-js prettyprint badcode">n                     // 缺乏语义
nErr                  // 语义模糊的缩写
nCompConns            // 语义模糊的缩写
wgcConnections        // 只有自己项目组成员明白其含义
pcReader              // pc可以代表许多含义
cstmrId               // 删除中间字符
kSecondsPerDay        // 不要使用匈牙利命名法
</code></pre>

<h3 id="naming-rules-by-identifier-type">6.2 Rules by identifier type</h3>

<h4 id="naming-package-names">6.2.1 Package命名</h4>

<p>Package统一使用小驼峰法命名，例如使用<code>my.exampleCode.deepSpace</code>，
  不要使用<code class="badcode">my.examplecode.deepspace</code>或者<code class="badcode">my.example_code.deep_space</code>。</p>

<h4 id="naming-class-names">6.2.2 类命名</h4>

<p>类、接口使用大驼峰命名法。局部的但不是私有的类称为非导出类（unexported classes），这些类不会添加<code>@private</code>注解，因此其名字也不需要以下划线结尾。</p>

<p>类型名一般是名词或者名词短语，例如<code>Request</code>、<code>ImmutableList</code>、<code>VisibilityMode</code>。
  此外，接口名可以是形容词或者形容词类型的短语，例如<code>Readable</code>。</p>

<h4 id="naming-method-names">6.2.3 函数名</h4>

<p>函数使用小驼峰法命名，私有函数名称以下划线结尾。</p>

<p>方法名一般是动词或动词短语，例如<code>sendMessage</code>或者<code>stop_</code>。
  函数的getter和setter方法不是必要的，如果有的话应该使用<code>getFoo</code>和<code>setFoo(value)</code>的形式。</p>

<p>下划线也可以在测试用例名称中用于分隔名称的不同部分，一种典型用法是<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，
  例如<code>testPop_emptyStack</code>>。测试用例命名没有统一的方法。</p>

<h4 id="naming-enum-names">6.2.4 枚举命名</h4>

<p>枚举使用大驼峰命名法。，一般使用单个名词。枚举元素参照常量命名。</p>

<h4 id="naming-constant-names">6.2.5 常量命名</h4>

<p>常量采用大写常量命名方式（CONSTANT_CASE）：所有字符大写，使用下划线连接多个单词。不需要使用尾下划线，因为静态私有属性可以使用模块局部常量代替。</p>

<h5 id="naming-definition-of-constant">6.2.5.1 常量定义 of &#8220;constant&#8221;</h5>

<p>常量是添加<code>@const</code>注解的静态属性或者模块局部的<code>const</code>声明，但不是所有这些用法都是常量。
  能否作为常量的原则是其是否是深度不变的（deeply immutable）。例如如果一个实例的任何一个可观测状态可能发生变化，那么它就不是常量。
  仅仅不修改对象实例是不够的。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">// 常量
const NUMBER = 5;
/** @const */ exports.NAMES = ImmutableList.of('Ed', 'Ann');
/** @enum */ exports.SomeEnum = { ENUM_CONSTANT: 'value' };

// 非常量
let letVariable = 'non-const';
class MyClass { constructor() { /** @const */ this.nonStatic = 'non-static'; } };
/** @type {string} */ MyClass.staticButMutable = 'not @const, can be reassigned';
const /** Set&lt;String&gt; */ mutableCollection = new Set();
const /** ImmutableSet&lt;SomeMutableType&gt; */ mutableElements = ImmutableSet.of(mutable);
const Foo = goog.require('my.Foo');  // mirrors imported name
const logger = log.getLogger('loggers.are.not.immutable');
</code></pre>

<p>常量名一般是名词或者名词短语></p>

<h5 id="naming-local-aliases">6.2.5.1 本地别名</h5>

<p>常使用本地别名代替完整以增强可读性。本地别名命名参照<code>goog.require</code>s
（<a href="#file-goog-require">??</a>），一般使用原名称最后一部分作为别名。别名必须使用<code>const</code>声明。</p>

<p>示例：</p>

<pre><code class="language-js prettyprint">const staticHelper = importedNamespace.staticHelper;
const CONSTANT_NAME = ImportedClass.CONSTANT_NAME;
const {assert, assertInstanceof} = asserts;
</code></pre>

<h4 id="naming-non-constant-field-names">6.2.6 非常量字段名</h4>

<p>非常量字段名（无论是否静态）使用小驼峰命名法，私有字段以下划线结尾。</p>

<p>字段名一般是名词或者名词短语，例如<code>computedValues</code>或者<code>index_</code>。</p>

<h4 id="naming-parameter-names">6.2.7 参数名</h4>

<p>参数名使用小驼峰命名法。</p>

<p>公开方法参数不能使用单字符参数名。</p>

<p><strong>例外</strong>：如果第三方框架需要，参数名可以以<code>$</code>开头。</p>

<h4 id="naming-local-variable-names">6.2.8 局部变量命名</h4>

<p>局部变量使用小驼峰命名法，前面提到的模块顶层局部常量除外。函数内部的常量仍然使用小驼峰命名法。即使变量包含的是构造函数，也仍然使用小驼峰法命名。</p>

<h4 id="naming-template-parameter-names">6.2.9 模板参数命名</h4>

<p>模板参数命名应该简洁，一般是单个单词或者单字符，且全大写，例如<code>TYPE</code>或者<code>THIS</code>。</p>

<h3 id="naming-camel-case-defined">6.3 Camel case: defined</h3>

<p>对于首字母缩略词等情况（例如<q>IPv6</q>或者<q>iOS</q>）来说，没有确定的方式将其转换为驼峰式写法。为增强可预测性，本代码规范制定了下列转换方法。以</p>

<p>转换规则以名称的普通可读文本形式作为输入：</p>

<ol>
<li>将其转换为普通ASCII，移除单引号。例如，<q>M&#252;ller's algorithm</q>会被转换<q>Muellers algorithm</q>。</li>
<li>根据空格、连字符或其他标点符号将结果分隔为多个词。
<ol>
<li>建议：如果一个词已经有常见的驼峰写法，将其分割为多个连续的部分（例如将<q>AdWords</q>分割为<q>ad words</q>）。
  注意有些词本身并不属于驼峰写法，例如<q>iOS</q>，这种写法不符合任何管理，因此不适用该建议。</li>
</ol></li>
<li>全部转换为小写，然后对于大驼峰法将所有单词的首字符大写，对于小驼峰法将除第一个之外单词首字符大写。
<li>最后将所有单词拼接为一个标志符。</li>
</ol>

<p>注意以上过程几乎完全不考虑名称的原始大小写。</p>

<p>示例：</p>

<table>
<thead>
<tr>
<th style="text-align: center">Prose form</th>
<th style="text-align: center">Correct</th>
<th style="text-align: center">Incorrect</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center"><q>XML HTTP request</q></td>
<td style="text-align: center">XmlHttpRequest</td>
<td style="text-align: center">XMLHTTPRequest</td>
</tr>
<tr>
<td style="text-align: center"><q>new customer ID</q></td>
<td style="text-align: center">newCustomerId</td>
<td style="text-align: center">newCustomerID</td>
</tr>
<tr>
<td style="text-align: center"><q>inner stopwatch</q></td>
<td style="text-align: center">innerStopwatch</td>
<td style="text-align: center">innerStopWatch</td>
</tr>
<tr>
<td style="text-align: center"><q>supports IPv6 on iOS?</q></td>
<td style="text-align: center">supportsIpv6OnIos</td>
<td style="text-align: center">supportsIPv6OnIOS</td>
</tr>
<tr>
<td style="text-align: center"><q>YouTube importer</q></td>
<td style="text-align: center">YouTubeImporter</td>
<td style="text-align: center">YoutubeImporter*</td>
</tr>
</tbody>
</table>

<p>*可接受，单不推荐。</p>

<p>注意：英语中有些词可使用也可不用连字符，例如<q>nonempty</q>和<q>non-empty</q>都是正确的，因此函数名checkNonempty和checkNonEmpty也都是合法的。</p>

<h2 id="jsdoc">7 JSDoc</h2>

<p><a href="https://developers.google.com/closure/compiler/docs/js-for-compiler">JSDoc</a> is used on all classes, fields, and methods.</p>

<h3 id="jsdoc-general-form">7.1 General form</h3>

<p>The basic formatting of JSDoc blocks is as seen in this example:</p>

<pre><code class="language-js prettyprint">/**
 * Multiple lines of JSDoc text are written here,
 * wrapped normally.
 * @param {number} arg A number to do something to.
 */
function doSomething(arg) { &#8230; }
</code></pre>

<p>or in this single-line example:</p>

<pre><code class="language-js prettyprint">/** @const @private {!Foo} A short bit of JSDoc. */
this.foo_ = foo;
</code></pre>

<p>If a single-line comment overflows into multiple lines, it must use the
multi-line style with <code>/**</code> and <code>*/</code> on their own lines.</p>

<p>Many tools extract metadata from JSDoc comments to perform code validation and
optimization.  As such, these comments <strong>must</strong> be well-formed.</p>

<h3 id="jsdoc-markdown">7.2 Markdown</h3>

<p>JSDoc is written in Markdown, though it may include HTML when necessary.</p>

<p>Note that tools that automatically extract JSDoc (e.g. <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) will often
ignore plain text formatting, so if you did this:</p>

<pre><code class="language-js prettyprint badcode">/**
 * Computes weight based on three factors:
 *   items sent
 *   items received
 *   last timestamp
 */
</code></pre>

<p>it would come out like this:</p>

<pre><code>Computes weight based on three factors: items sent items received last timestamp
</code></pre>

<p>Instead, write a Markdown list:</p>

<pre><code class="language-js prettyprint">/**
 * Computes weight based on three factors:
 *  - items sent
 *  - items received
 *  - last timestamp
 */
</code></pre>

<h3 id="jsdoc-tags">7.3 JSDoc tags</h3>

<p>Google style allows a subset of JSDoc tags.  See
<a href="#appendices-jsdoc-tag-reference">??</a> for the complete list.  Most tags must
occupy their own line, with the tag at the beginning of the line.</p>

<p>Illegal:</p>

<pre><code class="language-js prettyprint badcode">/**
 * The "param" tag must occupy its own line and may not be combined.
 * @param {number} left @param {number} right
 */
function add(left, right) { ... }
</code></pre>

<p>Simple tags that do not require any additional data (such as <code>@private</code>,
<code>@const</code>, <code>@final</code>, <code>@export</code>) may be combined onto the same line, along with an
optional type when appropriate.</p>

<pre><code class="language-js prettyprint">/**
 * Place more complex annotations (like "implements" and "template")
 * on their own lines.  Multiple simple tags (like "export" and "final")
 * may be combined in one line.
 * @export @final
 * @implements {Iterable&lt;TYPE&gt;}
 * @template TYPE
 */
class MyClass {
  /**
   * @param {!ObjType} obj Some object.
   * @param {number=} num An optional number.
   */
  constructor(obj, num = 42) {
    /** @private @const {!Array&lt;!ObjType|number&gt;} */
    this.data_ = [obj, num];
  }
}
</code></pre>

<p>There is no hard rule for when to combine tags, or in which order, but be
consistent.</p>

<p>For general information about annotating types in JavaScript see
<a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a> and <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
System</a>.</p>

<h3 id="jsdoc-line-wrapping">7.4 Line wrapping</h3>

<p>Line-wrapped block tags are indented four spaces.  Wrapped description text may
be lined up with the description on previous lines, but this horizontal
alignment is discouraged.</p>

<pre><code class="language-js prettyprint">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */
exports.method = function(foo) {
  return 5;
};
</code></pre>

<p>Do not indent when wrapping a <code>@fileoverview</code> description.</p>

<h3 id="jsdoc-top-file-level-comments">7.5 Top/file-level comments</h3>

<p>A file may have a top-level file overview. A copyright notice , author information, and
default <a href="#jsdoc-visibility-annotations">visibility level</a> are optional.  File overviews are generally recommended whenever a
file consists of more than a single class definition. The top level comment is
designed to orient readers unfamiliar with the code to what is in this file. If
present, it may provide a description of the file's contents and any
dependencies or compatibility information. Wrapped lines are not indented.</p>

<p>Example:</p>

<pre><code class="language-js prettyprint">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @package
 */
</code></pre>

<h3 id="jsdoc-class-comments">7.6 Class comments</h3>

<p>Classes, interfaces and records must be documented with a description and any
template parameters, implemented interfaces, visibility, or other appropriate
tags. The class description should provide the reader with enough information to
know how and when to use the class, as well as any additional considerations
necessary to correctly use the class. Textual descriptions may be omitted on the
constructor. <code>@constructor</code> and <code>@extends</code> annotations are not used with the
<code>class</code> keyword unless the class is being used to declare an <code>@interface</code> or
it extends a generic class.</p>

<pre><code class="language-js prettyprint">/**
 * A fancier event target that does cool things.
 * @implements {Iterable&lt;string&gt;}
 */
class MyFancyTarget extends EventTarget {
  /**
   * @param {string} arg1 An argument that makes this more interesting.
   * @param {!Array&lt;number&gt;} arg2 List of numbers to be processed.
   */
  constructor(arg1, arg2) {
    // ...
  }
};

/**
 * Records are also helpful.
 * @extends {Iterator&lt;TYPE&gt;}
 * @record
 * @template TYPE
 */
class Listable {
  /** @return {TYPE} The next item in line to be returned. */
  next() {}
}
</code></pre>

<h3 id="jsdoc-enum-and-typedef-comments">7.7 Enum and typedef comments</h3>

<p>Enums and typedefs must be documented.  Public enums and typedefs must have a
non-empty description.  Individual enum items may be documented with a JSDoc
comment on the preceding line.</p>

<pre><code class="language-js prettyprint">/**
 * A useful type union, which is reused often.
 * @typedef {!Bandersnatch|!BandersnatchType}
 */
let CoolUnionType;


/**
 * Types of bandersnatches.
 * @enum {string}
 */
const BandersnatchType = {
  /** This kind is really frumious. */
  FRUMIOUS: 'frumious',
  /** The less-frumious kind. */
  MANXOME: 'manxome',
};
</code></pre>

<p>Typedefs are useful for defining short record types, or aliases for unions,
complex functions, or generic types.
Typedefs should be avoided for record types with many fields, since they do not
allow documenting individual fields, nor using templates or recursive
references.
For large record types, prefer <code>@record</code>.</p>

<h3 id="jsdoc-method-and-function-comments">7.8 Method and function comments</h3>

<p>Parameter and return types must be documented. The <code>this</code> type should be
documented when necessary. Method, parameter, and return descriptions (but not
types) may be omitted if they are obvious from the rest of the method&#8217;s JSDoc or
from its signature. Method descriptions should start with a sentence written in
the third person declarative voice.  If a method overrides a superclass method,
it must include an <code>@override</code> annotation.  Overridden methods must include all
<code>@param</code> and <code>@return</code> annotations if any types are refined, but should omit
them if the types are all the same.</p>

<pre><code class="language-js prettyprint">/** This is a class. */
class SomeClass extends SomeBaseClass {
  /**
   * Operates on an instance of MyClass and returns something.
   * @param {!MyClass} obj An object that for some reason needs detailed
   *     explanation that spans multiple lines.
   * @param {!OtherClass} obviousOtherClass
   * @return {boolean} Whether something occurred.
   */
  someMethod(obj, obviousOtherClass) { ... }

  /** @override */
  overriddenMethod(param) { ... }
}

/**
 * Demonstrates how top-level functions follow the same rules.  This one
 * makes an array.
 * @param {TYPE} arg
 * @return {!Array&lt;TYPE&gt;}
 * @template TYPE
 */
function makeArray(arg) { ... }
</code></pre>



<p>Anonymous functions do not require JSDoc, though parameter types may be specified inline if the automatic type inference is insufficient.</p>

<pre><code class="language-js prettyprint">promise.then(
    (/** !Array&lt;number|string&gt; */ items) =&gt; {
      doSomethingWith(items);
      return /** @type {string} */ (items[0]);
    });
</code></pre>

<h3 id="jsdoc-property-comments">7.9 Property comments</h3>

<p>Property types must be documented. The description may be omitted for private
properties, if name and type provide enough documentation for understanding the
code.</p>

<p>Publicly exported constants are commented the same way as properties.  Explicit
types may be omitted for <code>@const</code> properties initialized from an expression with
an obviously known type.</p>

<p>Tip: A <code>@const</code> property&#8217;s type can be considered &#8220;obviously known&#8221; if it is
assigned directly from a constructor parameter with a declared type, or directly
from a function call with a declared return type.  Non-const properties and
properties assigned from more complex expressions should have their types
declared explicitly.</p>

<pre><code class="language-js prettyprint">/** My class. */
class MyClass {
  /** @param {string=} someString */
  constructor(someString = 'default string') {
    /** @private @const */
    this.someString_ = someString;

    /** @private @const {!OtherType} */
    this.someOtherThing_ = functionThatReturnsAThing();

    /**
     * Maximum number of things per pane.
     * @type {number}
     */
    this.someProperty = 4;
  }
}

/**
 * The number of times we'll try before giving up.
 * @const
 */
MyClass.RETRY_COUNT = 33;
</code></pre>

<h3 id="jsdoc-type-annotations">7.10 Type annotations</h3>

<p>Type annotations are found on <code>@param</code>, <code>@return</code>, <code>@this</code>, and <code>@type</code> tags,
and optionally on <code>@const</code>, <code>@export</code>, and any visibility tags.  Type
annotations attached to JSDoc tags must always be enclosed in braces.</p>

<h4 id="jsdoc-nullability">7.10.1 Nullability</h4>

<p>The type system defines modifiers <code>!</code> and <code>?</code> for non-null and nullable,
respectively.  Primitive types (<code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>,
<code>symbol</code>, and <code>function(...): ...</code>) and record literals (<code>{foo: string, bar:
number}</code>) are non-null by default.  Do not add an explicit <code>!</code> to these types.
Object types (<code>Array</code>, <code>Element</code>, <code>MyClass</code>, etc) are nullable by default, but
cannot be immediately distinguished from a name that is <code>@typedef</code>&#8217;d to a
non-null-by-default type.  As such, all types except primitives and record
literals must be annotated explicitly with either <code>?</code> or <code>!</code> to indicate whether
they are nullable or not.</p>

<h4 id="jsdoc-type-casts">7.10.2 Type Casts</h4>

<p>In cases where type checking doesn't accurately infer the type of an expression,
it is possible to tighten the type by adding a type annotation comment and
enclosing the expression in parentheses. Note that the parentheses are required.</p>

<pre><code class="language-js prettyprint">/** @type {number} */ (x)
</code></pre>

<h4 id="jsdoc-template-parameter-types">7.10.3 Template Parameter Types</h4>

<p>Always specify template parameters. This way compiler can do a better job and it
makes it easier for readers to understand what code does.</p>

<p>Bad:</p>

<pre><code class="language-js prettyprint badcode">const /** !Object */ users = {};
const /** !Array */ books = [];
const /** !Promise */ response = ...;
</code></pre>

<p>Good:</p>

<pre><code class="language-js prettyprint">const /** !Object&lt;string, !User&gt; */ users = {};
const /** !Array&lt;string&gt; */ books = [];
const /** !Promise&lt;!Response&gt; */ response = ...;

const /** !Promise&lt;undefined&gt; */ thisPromiseReturnsNothingButParameterIsStillUseful = ...;
const /** !Object&lt;string, *&gt; */ mapOfEverything = {};
</code></pre>

<p>Cases when template parameters should not be used:</p>

<ul>
<li><code>Object</code> is used for type hierarchy and not as map-like structure.</li>
</ul>

<h3 id="jsdoc-visibility-annotations">7.11 Visibility annotations</h3>

<p>Visibility annotations (<code>@private</code>, <code>@package</code>, <code>@protected</code>) may be specified
in a <code>@fileoverview</code> block, or on any exported symbol or property.  Do not
specify visibility for local variables, whether within a function or at the top
level of a module.  All <code>@private</code> names must end with an underscore.</p>

<h2 id="appendices">9 Appendices</h2>

<h3 id="appendices-jsdoc-tag-reference">9.1 JSDoc tag reference</h3>

<p>JSDoc serves multiple purposes in JavaScript.  In addition to being used to
generate documentation it is also used to control tooling.  The best known are
the Closure Compiler type annotations.</p>

<h4 id="appendices-type-annotations">9.1.1 Type annotations and other Closure Compiler annotations</h4>

<p>Documentation for JSDoc used by the Closure Compiler is described in
<a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure Compiler</a> and <a href="https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System">Types in the Closure Type
System</a>.</p>

<h4 id="appendices-documentation-annotations">9.1.2 Documentation annotations</h4>

<p>In addition to the JSDoc described in <a href="https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler">Annotating JavaScript for the Closure
Compiler</a> the following tags are common and well supported by various
documentation generations tools (such as <a href="https://github.com/jleyba/js-dossier">JsDossier</a>) for purely documentation
purposes.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@author</code> or <code>@owner</code>
      </td><td><code>@author username@google.com (First Last)</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Utilities for handling textareas.
 * @author <a href="mailto:kuth@google.com">kuth@google.com</a> (Uthur Pendragon)
 */
 </pre>
      </td><td>Document the author of a file or the owner of a test, generally only
        used in the <code>@fileoverview</code> comment. The <code>@owner</code> tag is used by the
        unit test dashboard to determine who owns the test results.
        <p>Not recommended.
    </p></td></tr><tr>
      <td><code>@bug</code>
      </td><td><code>@bug bugnumber</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @bug 1234567 */
function testSomething() {
  // &#8230;
}

<p>/**
 * @bug 1234568
 * @bug 1234569
 */
function testTwoBugs() {
  // &#8230;
}
</p></pre>
      </td><td>Indicates what bugs the given test function regression tests.
        <p>Multiple bugs should each have their own <code>@bug</code> line, to make
        searching for regression tests as easy as possible.
    </p></td></tr><tr>
      <td><code>@code</code>
      </td><td><code>{@code ...}</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Moves to the next position in the selection.
 * Throws {@code goog.iter.StopIteration} when it
 * passes the end of the range.
 * @return {!Node} The node at the next position.
 */
goog.dom.RangeIterator.prototype.next = function() {
  // &#8230;
};
</pre>
      </td><td>Indicates that a term in a JSDoc description is code so it may be
        correctly formatted in generated documentation.
    </td></tr><tr>
      <td><code>@see</code>
      </td><td><code>@see Link</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * Adds a single item, recklessly.
 * @see #addSafely
 * @see goog.Collect
 * @see goog.RecklessAdder#add
 */
 </pre>
       </td><td>Reference a lookup to another class function or method.
    </td></tr><tr>
      <td><code>@supported</code>
      </td><td><code>@supported Description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/**
 * @fileoverview Event Manager
 * Provides an abstracted interface to the
 * browsers' event systems.
 * @supported IE10+, Chrome, Safari
 */
</pre>
      </td><td>Used in a fileoverview to indicate what browsers are supported by
        the file.
    </td></tr><tr>
      <td><code>@desc</code>
      </td><td><code>@desc Message description</code>
        <p><em>For example:</em>
        </p><pre class="prettyprint lang-js">
/** @desc Notifying a user that their account has been created. */
exports.MSG_ACCOUNT_CREATED = goog.getMsg(
    'Your account has been successfully created.');
 </pre>
      </td></tr></tbody></table></p>

<p>You may also see other types of JSDoc annotations in third-party code. These
annotations appear in the <a href="http://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc Toolkit Tag Reference</a> but are not considered
part of valid Google style.</p>

<h4 id="appendices-framework-specific-annotations">9.1.3 Framework specific annotations</h4>

<p>The following annotations are specific to a particular framework.
<table>
  <thead>
    <tr>
      <th>Framework
      </th><th>Tag
      </th><th>Documentation
  </th></tr></thead><tbody>
    <tr>
      <td>Angular 1
      </td><td><code>@ngInject</code>
      </td></tr><tr>
      <td>Polymer
      </td><td><code>@polymerBehavior</code>
      </td><td>
          
            <a href="https://github.com/google/closure-compiler/wiki/Polymer-Pass">https://github.com/google/closure-compiler/wiki/Polymer-Pass</a>
          
    </td></tr></tbody></table></p>

<h4 id="appendices-notes-about-standard-closure-compiler-annotations">9.1.4 Notes about standard Closure Compiler annotations</h4>

<p>The following tags used to be standard but are now deprecated.
<table>
  <thead>
    <tr>
      <th>Tag
      </th><th>Template &amp; Examples
      </th><th>Description
  </th></tr></thead><tbody>
    <tr>
      <td><code>@expose</code>
      </td><td><code>@expose</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@export</code> and/or <code>@nocollapse</code>
        instead.</strong>
    </td></tr><tr>
      <td><code>@inheritDoc</code>
      </td><td><code>@inheritDoc</code>
      </td><td><strong>Deprecated. Do not use. Use <code>@override</code> instead.</strong>
</td></tr></tbody></table></p>

<h3 id="appendices-commonly-misunderstood-style-rules">9.2 Commonly misunderstood style rules</h3>

<p>Here is a collection of lesser-known or commonly misunderstood facts about
Google Style for JavaScript. (The following are true statements; this is not a
list of <q>myths.</q>)</p>

<ul>
<li>Neither a copyright statement nor <code>@author</code> credit is required in a source
file. (Neither is explicitly recommended, either.)</li>
<li>Aside from the constructor coming first
(<a href="#features-classes-constructors">??</a>), there is no <q>hard and fast</q> rule
governing how to order the members of a class (<a href="#features-classes">??</a>).</li>
<li>Empty blocks can usually be represented concisely as <code>{}</code>, as detailed in
(<a href="#formatting-empty-blocks">??</a>).</li>
<li>The prime directive of line-wrapping is: prefer to break at a higher
syntactic level (<a href="#formatting-where-to-break">??</a>).</li>
<li>Non-ASCII characters are allowed in string literals, comments and Javadoc,
and in fact are recommended when they make the code easier to read than the
equivalent Unicode escape would (<a href="#non-ascii-characters">??</a>).</li>
</ul>

<h3 id="appendices-style-related-tools">9.3 Style-related tools</h3>

<p>The following tools exist to support various aspects of Google Style.</p>

<h4 id="appendices-tools-closure-compiler">9.3.1 Closure Compiler</h4>

<p>This program performs type checking and other checks,
optimizations and other transformations (such as ECMAScript 6 to ECMAScript 5
code lowering).</p>

<h4 id="appendices-clang-format">9.3.2 <code>clang-format</code></h4>

<p>This program  reformats
JavaScript source code into Google Style, and also follows a number of
non-required but frequently readability-enhancing formatting practices.</p>

<p><code>clang-format</code> is not required. Authors are allowed to change its output, and
reviewers are allowed to ask for such changes; disputes are worked out in the
usual way. However, subtrees may choose to opt in to such enforcement locally.</p>

<h4 id="appendices-closure-compiler-linter">9.3.3 Closure compiler linter</h4>

<p>This program  checks for a
variety of missteps and anti-patterns.
</p>

<h4 id="appendices-conformance-framework">9.3.4 Conformance framework</h4>

<p>The JS Conformance Framework is a tool that is part of the Closure Compiler that
provides developers a simple means to specify a set of additional checks to be
run against their code base above the standard checks.  Conformance checks can,
for example, forbid access to a certain property, or calls to a certain
function, or missing type information (unknowns).</p>

<p>These rules are commonly used to enforce critical restrictions (such as defining
globals, which could break the codebase) and security patterns (such as using
<code>eval</code> or assigning to <code>innerHTML</code>), or more loosely to improve code quality.</p>

<p>For additional information see the official documentation for the
<a href="https://github.com/google/closure-compiler/wiki/JS-Conformance-Framework">JS Conformance Framework</a>.</p>

<h3 id="appendices-legacy-exceptions">9.4 Exceptions for legacy platforms</h3>

<h4 id="appendices-legacy-exceptions-overview">9.4.1 Overview</h4>

<p>This section describes exceptions and additional rules to be followed when
modern ECMAScript 6 syntax is not available to the code authors. Exceptions to
the recommended style are required when ECMAScript 6 syntax is not possible and
are outlined here:</p>

<ul>
<li>Use of <code>var</code> declarations is allowed</li>
<li>Use of <code>arguments</code> is allowed</li>
<li>Optional parameters without default values are allowed</li>
</ul>

<h4 id="appendices-legacy-exceptions-var">9.4.2 Use <code>var</code></h4>

<h5 id="appendices-legacy-exceptions-var-scope">9.4.2.1 <code>var</code> declarations are NOT block-scoped</h5>

<p><code>var</code> declarations are scoped to the beginning of the nearest enclosing
function, script or module, which can cause unexpected behavior, especially with
function closures that reference <code>var</code> declarations inside of loops. The
following code gives an example:</p>

<pre><code class="language-js prettyprint badcode">for (var i = 0; i &lt; 3; ++i) {
  var iteration = i;
  setTimeout(function() { console.log(iteration); }, i*1000);
}

// logs 2, 2, 2 -- NOT 0, 1, 2
// because `iteration` is function-scoped, not local to the loop.

</code></pre>

<h5 id="appendices-legacy-exceptions-var-declare">9.4.2.2 Declare variables as close as possible to first use</h5>

<p>Even though <code>var</code> declarations are scoped to the beginning of the enclosing
function, <code>var</code> declarations should be as close as possible to their first use,
for readability purposes. However, do not put a <code>var</code> declaration inside a block
if that variable is referenced outside the block. For example:</p>

<pre><code class="language-js prettyprint">function sillyFunction() {
  var count = 0;
  for (var x in y) {
    // "count" could be declared here, but don't do that.
    count++;
  }
  console.log(count + ' items in y');
}
</code></pre>

<h5 id="appendices-legacy-exceptions-var-const">9.4.2.3 Use @const for constants variables</h5>

<p>For global declarations where the <code>const</code> keyword would be used, if it were
available, annotate the <code>var</code> declaration with @const instead (this is optional
for local variables).</p>

<h4 id="appendices-legacy-exceptions-function">9.4.3 Do not use block scoped functions declarations</h4>

<p>Do <strong>not</strong> do this:</p>

<pre><code class="language-js prettyprint badcode">if (x) {
  function foo() {}
}
</code></pre>

<p>While most JavaScript VMs implemented before ECMAScript 6 support function
declarations within blocks it was not standardized. Implementations were
inconsistent with each other and with the now-standard ECMAScript 6 behavior for
block scoped function declaration. ECMAScript 5 and prior only allow for
function declarations in the root statement list of a script or function and
explicitly ban them in block scopes in strict mode.</p>

<p>To get consistent behavior, instead use a <code>var</code> initialized with a function
expression to define a function within a block:</p>

<pre><code class="language-js prettyprint">if (x) {
  var foo = function() {};
}
</code></pre>

<h4 id="appendices-legacy-exceptions-goog-provide">9.4.4 Dependency management with <code>goog.provide</code>/<code>goog.require</code></h4>

<p><strong><code>goog.provide</code> is deprecated. All new files should use <code>goog.module</code>, even in
projects with existing <code>goog.provide</code> usage. The following rules are for
pre-existing goog.provide files, only.</strong></p>

<h5 id="appendices-legacy-exceptions-goog-provide-summary">9.4.4.1 Summary</h5>

<ul>
<li>Place all <code>goog.provide</code>s first, <code>goog.require</code>s second. Separate provides
from requires with an empty line.</li>
<li>Sort the entries alphabetically (uppercase first).</li>
<li>Don't wrap <code>goog.provide</code> and <code>goog.require</code> statements. Exceed 80 columns
if necessary.</li>
<li>Only provide top-level symbols.</li>
</ul>

<p>As of Oct 2016, <strong><code>goog.provide</code>/<code>goog.require</code> dependency management is
deprecated</strong>. All new files, even in projects using <code>goog.provide</code> for older
files, should use
<a href="#source-file-structure"><code>goog.module</code></a>.</p>

<p><code>goog.provide</code> statements should be grouped together and placed first. All
<code>goog.require</code> statements should follow. The two lists should be separated with
an empty line.</p>

<p>Similar to import statements in other languages, <code>goog.provide</code> and
<code>goog.require</code> statements should be written in a single line, even if they
exceed the 80 column line length limit.</p>

<p>The lines should be sorted alphabetically, with uppercase letters coming first:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
goog.provide('namespace.helperFoo');

goog.require('an.extremelyLongNamespace.thatSomeoneThought.wouldBeNice.andNowItIsLonger.Than80Columns');
goog.require('goog.dom');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.dominoes');

</code></pre>

<p>All members defined on a class should be in the same file. Only top-level
classes should be provided in a file that contains multiple members defined on
the same class (e.g. enums, inner classes, etc).</p>

<p>Do this:</p>

<pre><code class="language-js prettyprint">goog.provide('namespace.MyClass');
</code></pre>

<p>Not this:</p>

<pre><code class="language-js prettyprint badcode">goog.provide('namespace.MyClass');
goog.provide('namespace.MyClass.CONSTANT');
goog.provide('namespace.MyClass.Enum');
goog.provide('namespace.MyClass.InnerClass');
goog.provide('namespace.MyClass.TypeDef');
goog.provide('namespace.MyClass.staticMethod');
</code></pre>

<p>Members on namespaces may also be provided:</p>

<pre><code class="language-js prettyprint">goog.provide('foo.bar');
goog.provide('foo.bar.CONSTANT');
goog.provide('foo.bar.method');
</code></pre>

<h5 id="appendices-legacy-exceptions-goog-scope">9.4.4.2 Aliasing with <code>goog.scope</code></h5>

<p><strong><code>goog.scope</code> is deprecated. New files should not use <code>goog.scope</code> even in
projects with existing goog.scope usage.</strong></p>

<p><code>goog.scope</code> may be used to shorten references to namespaced symbols in
code using <code>goog.provide</code>/<code>goog.require</code> dependency management.</p>

<p>Only one <code>goog.scope</code> invocation may be added per file. Always place it in
the global scope.</p>

<p>The opening <code>goog.scope(function() {</code> invocation must be preceded by exactly one
blank line and follow any <code>goog.provide</code> statements, <code>goog.require</code> statements,
or top-level comments. The invocation must be closed on the last line in the
file. Append <code>// goog.scope</code> to the closing statement of the scope. Separate the
comment from the semicolon by two spaces.</p>

<p>Similar to C++ namespaces, do not indent under <code>goog.scope</code> declarations.
Instead, continue from the 0 column.</p>

<p>Only make aliases for names that will not be re-assigned to another object
(e.g., most constructors, enums, and namespaces). Do not do this (see below for
how to alias a constructor):</p>

<pre><code class="language-js prettyprint badcode">goog.scope(function() {
var Button = goog.ui.Button;

Button = function() { ... };
...
</code></pre>

<p>Names must be the same as the last property of the global that they are aliasing.</p>

<pre><code class="language-js prettyprint">goog.provide('my.module.SomeType');

goog.require('goog.dom');
goog.require('goog.ui.Button');

goog.scope(function() {
var Button = goog.ui.Button;
var dom = goog.dom;

// Alias new types after the constructor declaration.
my.module.SomeType = function() { ... };
var SomeType = my.module.SomeType;

// Declare methods on the prototype as usual:
SomeType.prototype.findButton = function() {
  // Button as aliased above.
  this.button = new Button(dom.getElement('my-button'));
};
...
});  // goog.scope
</code></pre>

</div>
</body>
</html>
